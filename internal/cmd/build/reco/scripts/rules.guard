#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#  CODEBUILD_PROJECT_SOURCE_REPO_URL_CHECK
#
# Description:
#  Checks whether the GitHub or Bitbucket source repository URL contains either personal access tokens or user name and password.
#
# Reports on:
#  AWS::CodeBuild::Project
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no AWS::CodeBuild::Project resources
# b) SKIP: when metadata has rule suppression for CODEBUILD_PROJECT_SOURCE_REPO_URL_CHECK
# c) FAIL: when a CodeBuild Project primary source location includes credentials
# d) FAIL: when any CodeBuild Project secondary source locations include a credential
# e) PASS: when no CodeBuild Project primary or secondary source locations include credentials

#
# Select all Code Build Source Credentials resources from incoming template (payload)
#
let codebuild_project_source_repo_url_check = Resources.*[Type == "AWS::CodeBuild::Project"
	Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CODEBUILD_PROJECT_SOURCE_REPO_URL_CHECK"
]

let CODEBUILD_PROJECT_SOURCE_REPO_URL_CHECK_GITHUB_PATTERN = /^(http(s)?)(:\/\/github\.com\/)([^\/]+)\/([\w\.-]+)(\.git)?$/
let CODEBUILD_PROJECT_SOURCE_REPO_URL_CHECK_BITBUCKET_PATTERN = /^https?:\/\/bitbucket\.org/

rule CODEBUILD_PROJECT_SOURCE_REPO_URL_CHECK when %codebuild_project_source_repo_url_check !empty {
	%codebuild_project_source_repo_url_check[
        Properties.Source.Type == "GITHUB" 
	] {
		Properties {
			Source.Location exists
			Source.Location == %CODEBUILD_PROJECT_SOURCE_REPO_URL_CHECK_GITHUB_PATTERN
			<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
				Violation: GitHub or Bitbucket source repository URL contains either personal access tokens or user name and password.
				Fix: Remove credentials from source locations
			>>		
		}
	}
	%codebuild_project_source_repo_url_check[
        Properties.Source.Type == "BITBUCKET" 
	] {
		Properties {
			Source.Location exists
			Source.Location == %CODEBUILD_PROJECT_SOURCE_REPO_URL_CHECK_BITBUCKET_PATTERN
			<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
				Violation: GitHub or Bitbucket source repository URL contains either personal access tokens or user name and password.
				Fix: Remove credentials from source locations
			>>		
		}
	}

	%codebuild_project_source_repo_url_check[
        Properties.SecondarySources exists
        Properties.SecondarySources is_list
        Properties.SecondarySources not empty
	] {
		Properties { 
			SecondarySources[
				Type == "GITHUB"
			] {
				Location exists
				Location == %CODEBUILD_PROJECT_SOURCE_REPO_URL_CHECK_GITHUB_PATTERN
				<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
					Violation: GitHub or Bitbucket source repository URL contains either personal access tokens or user name and password.
					Fix: Remove credentials from source locations
				>>		
			}

			SecondarySources[
				Type == "BITBUCKET"
			] {
				Location exists
				Location == %CODEBUILD_PROJECT_SOURCE_REPO_URL_CHECK_BITBUCKET_PATTERN
				<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
					Violation: GitHub or Bitbucket source repository URL contains either personal access tokens or user name and password.
					Fix: Remove credentials from source locations
				>>		
			}
		}
	}
}


#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    CODEBUILD_PROJECT_ENVVAR_AWSCRED_CHECK
#
# Description:
#   Checks whether the project contains environment variables AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY
#
# Reports on:
#    AWS::CodeBuild::Project
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no AWS::CodeBuild::Project resources
# b) SKIP: when metada has rule suppression for CODEBUILD_PROJECT_ENVVAR_AWSCRED_CHECK
# c) FAIL: environment variables AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are present
# d) PASS: when environment variables AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are not present

#
# Select all Code Build resources from incoming template (payload)
#
let codebuild_project_envvar_awscred_check = Resources.*[ Type == "AWS::CodeBuild::Project"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CODEBUILD_PROJECT_ENVVAR_AWSCRED_CHECK"
]
let disallowed_names = ["AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY"]

rule CODEBUILD_PROJECT_ENVVAR_AWSCRED_CHECK when %codebuild_project_envvar_awscred_check !empty {
	%codebuild_project_envvar_awscred_check.Properties {
		Environment !exists OR
		Environment {
			EnvironmentVariables !exists OR
			EnvironmentVariables [
				Type == "PLAINTEXT"
			] { 
				Name NOT IN %disallowed_names
					<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
						Violation: AWS CodeBuild Projects are not configured with environment variables that contain credentials in PLAINTEXT 
						Fix: Remove environment variables that contain credentials in PLAINTEXT ("AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY")
					>>
			}
		}
	}
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   ECS_TASK_DEFINITION_USER_FOR_HOST_MODE_CHECK
#
# Description:
#  Checks if an Amazon Elastic Container Service (Amazon ECS) task definition with host networking mode has 'privileged' or 'user' container definitions.
#
# Reports on:
#  AWS::ECS::TaskDefinition
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no Autoscaling Group resources present
# b) SKIP: when metada has rule suppression for ECS_TASK_DEFINITION_USER_FOR_HOST_MODE_CHECK
# c) SKIP: 'ContainerDefinitions' property is not present
# d) SKIP: 'NetworkMode' property is either not present or set to a value other than 'host'
# e) FAIL: Entry in 'ContainerDefinitions' has 'User' not present or set to a root user value and 'Privileged' not present or set to 'false' 
# f) PASS: All entires in 'ContainerDefinitions' have either 'User' set to a non-root user value or 'Privileged' set to 'true'

#
# Select all ECS Task Definition Resources from incoming template
#
let ecs_task_definition_user_for_host_mode_check_resources = Resources.*[ Type == "AWS::ECS::TaskDefinition"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ECS_TASK_DEFINITION_USER_FOR_HOST_MODE_CHECK"
]

rule ECS_TASK_DEFINITION_USER_FOR_HOST_MODE_CHECK when %ecs_task_definition_user_for_host_mode_check_resources !empty {
    %ecs_task_definition_user_for_host_mode_check_resources[
        Properties {
            ContainerDefinitions exists
            ContainerDefinitions is_list
            ContainerDefinitions not empty

            NetworkMode exists
            NetworkMode is_string
            NetworkMode == "host" 
        }
     ] {      
        Properties.ContainerDefinitions[*] {
            when User exists
                 User in [ 0 , "0" , "root" , /^0:.*$/ , /^root:.*$/ ] {
                    Privileged exists
                    Privileged == true
                    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                        Violation: Amazon ECS task definitions using host networking mode must have container definitions that explicitly opt-in to privileged mode, where the container definition user is a root user.
                        Fix: In 'ContainerDefinitions', where 'User' has been set to a root user value, expliclty opt-in to privileged mode by setting 'Privileged' to 'true'
                    >>
            }
            when User not exists {
                Privileged exists
                Privileged == true
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: Amazon ECS task definitions using host networking mode must have container definitions that explicitly opt-in to privileged mode, where the container definition user is a root user.
                    Fix: In 'ContainerDefinitions', where 'User' has been set to a root user value, expliclty opt-in to privileged mode by setting 'Privileged' to 'true'
                >>        
            }            
        }       
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDWATCH_ALARM_ACTION_CHECK
#
# Description:
#   Checks whether CloudWatch alarms have at least one alarm action,
#   one Insufficient Data Actions action, or one OK action enabled.
#
# Reports on:
#    AWS::Logs::LogGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no cloudwatch alarm resources present
# b) PASS: when resource Metadata is set with rule suppressed
# c) PASS: when all cloudwatch alarm resources property Alarm Actions, Insufficient Data Actions, or OK Action set
# d) FAIL: when all cloudwatch alarms resources property Alarm Actions, Insufficient Data Actions, or OK Action are not set with valid value
# e) SKIP: when metada has rule suppression for CLOUDWATCH_ALARM_ACTION_CHECK

#
# Select all cloudwatch logs log group resources from incoming template (payload)
#
let cloudwatch_alarm_action_check = Resources.*[ Type == 'AWS::CloudWatch::Alarm'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDWATCH_ALARM_ACTION_CHECK"
]

rule CLOUDWATCH_ALARM_ACTION_CHECK when %cloudwatch_alarm_action_check !empty {
  %cloudwatch_alarm_action_check.Properties.AlarmActions exists or
  %cloudwatch_alarm_action_check.Properties.OKActions exists or
  %cloudwatch_alarm_action_check.Properties.InsufficientDataActions exists

  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudWatch Alarms should have at least one Alarm Action, one Insufficient Data Actions action, or one OK Action enabled.
    Fix: Set one Alarm Action, one Insufficient Data Actions action, or one OK Action on the CloudWatch Alarm resource.
  >>
}


#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CW_LOGGROUP_RETENTION_PERIOD_CHECK
#
# Description:
#   Checks whether Amazon CloudWatch LogGroup retention
#   period is set to specific number of days.
#
# Reports on:
#    AWS::Logs::LogGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no cloudwatch logs log group resources present
# b) PASS: when all cloudwatch logs log group resources property RetentionInDays is set
# c) FAIL: when all cloudwatch logs log group resources property RetentionInDays is not set with valid value
# d) SKIP: when metada has rule suppression for CW_LOGGROUP_RETENTION_PERIOD_CHECK

#
# Select all cloudwatch logs log group resources from incoming template (payload)
#
let cloudwatch_logs_retention_period = Resources.*[ Type == 'AWS::Logs::LogGroup'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CW_LOGGROUP_RETENTION_PERIOD_CHECK"
]

rule CW_LOGGROUP_RETENTION_PERIOD_CHECK when %cloudwatch_logs_retention_period !empty {
  %cloudwatch_logs_retention_period.Properties.RetentionInDays IN [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudWatch Log LogsGroup does not have RetentionInDays set.
    Fix: Set the RetentionInDays parameter to a value of 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, or 3653.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDWATCH_LOG_GROUP_ENCRYPTED
#
# Description:
#   Checks if a log group in Amazon CloudWatch Logs is encrypted with a
#   AWS Key Management Service (KMS) managed Customer Master Keys (CMK).
#
# Reports on:
#    AWS::Logs::LogGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no cloudwatch logs log group resources present
# b) PASS: when all cloudwatch logs log group resources property KmsKeyId is set
# c) FAIL: when all cloudwatch logs log group resources property KmsKeyId is not set with valid value
# d) SKIP: when metada has rule suppression for CLOUDWATCH_LOG_GROUP_ENCRYPTED

#
# Select all cloudwatch logs log group resources from incoming template (payload)
#
let cloudwatch_logs = Resources.*[ Type == 'AWS::Logs::LogGroup'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDWATCH_LOG_GROUP_ENCRYPTED"
]

rule CLOUDWATCH_LOG_GROUP_ENCRYPTED when %cloudwatch_logs !empty {
  %cloudwatch_logs.Properties.KmsKeyId exists
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudWatch Log LogsGroup does not have KmsKeyId set.
    Fix: Set the KmsKeyId parameter to a ARN.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    DMS_REPLICATION_NOT_PUBLIC
#
# Description:
#   Checks whether AWS Database Migration Service replication instances are not set to allow public.
#
# Reports on:
#    AWS::DMS::ReplicationInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there is no DMS Replication Instance present
# b) FAIL: When DMS Replication Instance is present and PubliclyAccessible property is set to true
# c) PASS: When DMS Replication Instance is present and PubliclyAccessible property is set to false
# c) PASS: When DMS Replication Instance is present and PubliclyAccessible property is not set
# d) SKIP: when metada has rule suppression for DMS_REPLICATION_NOT_PUBLIC

#
# Select all Redshift cluster resources from incoming template
#

let dms_replication_instances = Resources.*[ Type == 'AWS::DMS::ReplicationInstance'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DMS_REPLICATION_NOT_PUBLIC"
]

rule DMS_REPLICATION_NOT_PUBLIC when %dms_replication_instances !empty {
  %dms_replication_instances.Properties.PubliclyAccessible exists
  %dms_replication_instances.Properties.PubliclyAccessible == false
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: AWS Database Migration Service replication instances should not be public.
    Fix: Set the DMS Replication Instance property PubliclyAccessible parameter to true.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    FSX_RESOURCES_PROTECTED_BY_BACKUP_PLAN
#
# Description:
#    Checks if Amazon FSx File Systems are protected by a backup plan.
# Reports on:
#    AWS::FSx::FileSystem
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no FSx File Systems resources are present
# b) SKIP: when metadata includes the suppression for rule FSX_RESOURCES_PROTECTED_BY_BACKUP_PLAN
# c) FAIL: when any FSx File Systems resources do not have LustreConfiguration set with AutomatedBackupRetentionDays
# d) PASS: when all FSx File Systems resources have LustreConfiguration set with AutomatedBackupRetentionDays

let fsx_resources_protected_by_backup_plan = Resources.*[ Type == "AWS::FSx::FileSystem"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "FSX_RESOURCES_PROTECTED_BY_BACKUP_PLAN"
]

rule FSX_RESOURCES_PROTECTED_BY_BACKUP_PLAN when %fsx_resources_protected_by_backup_plan !empty {
	%fsx_resources_protected_by_backup_plan.Properties {
		when FileSystemType == "LUSTRE" {
			LustreConfiguration exists
			<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
				Violation: FSx File Systems are protected by a backup plan
				Fix: Set the LustreConfiguration
			>>

			LustreConfiguration {
				when DeploymentType exists
						DeploymentType IN [ "PERSISTENT_1", "PERSISTENT_2" ] {

					AutomaticBackupRetentionDays exists
					<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
						Violation: FSx File Systems are protected by a backup plan
						Fix: AutomaticBackupRetentionDays should be set
					>>
					AutomaticBackupRetentionDays > 0
					<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
						Violation: FSx File Systems are protected by a backup plan
						Fix: Set the AutomaticBackupRetentionDays property to value greater than 0
					>>

				}
			}
		}

		when FileSystemType == "ONTAP" {
			OntapConfiguration {
				AutomaticBackupRetentionDays exists
				<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
					Violation: FSx File Systems are protected by a backup plan
					Fix: AutomaticBackupRetentionDays should be set
				>>
				AutomaticBackupRetentionDays > 0
				<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
					Violation: FSx File Systems are protected by a backup plan
					Fix: Set the AutomaticBackupRetentionDays property to value greater than 0
				>>
			}
		}

		when FileSystemType == "OPENZFS" {
			OpenZFSConfiguration {
				AutomaticBackupRetentionDays exists
				<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
					Violation: FSx File Systems are protected by a backup plan
					Fix: Set the AutomaticBackupRetentionDays property
				>>
				AutomaticBackupRetentionDays > 0
				<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
					Violation: FSx File Systems are protected by a backup plan
					Fix: Set the AutomaticBackupRetentionDays property to value greater than 0
				>>
			}
		}

		when FileSystemType == "WINDOWS" {
			WindowsConfiguration {
				AutomaticBackupRetentionDays exists
				<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
					Violation: FSx File Systems are protected by a backup plan
					Fix: Set the AutomaticBackupRetentionDays property
				>>
				AutomaticBackupRetentionDays > 0
				<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
					Violation: FSx File Systems are protected by a backup plan
					Fix: Set the AutomaticBackupRetentionDays property to value greater than 0
				>>
			}
		}
	}
}

## Config Rule Name : api-gw-execution-logging-enabled
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/api-gw-execution-logging-enabled.html"

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   API_GWV2_ACCESS_LOGS_ENABLED
#
# Description:
#   Amazon API Gateway V2 stages have access logging enabled.
#
# Reports on:
#   AWS::ApiGateway::Stage
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no API GW Stage Methods present
# b) SKIP: when metadata includes the suppression for rule API_GWV2_ACCESS_LOGS_ENABLED
# c) FAIL: when an API Gateway V2 Stage Method is missing AccessLogSettings.DestinationArn or AccessLogSettings.Format
# d) FAIL: when an API Gateway V2 Stage Method has AccessLogSettings.DestinationArn or AccessLogSettings.Format set to a value other than a string or struct
# e) PASS: when an API Gateway V2 Stage Method have an AccessLogSettings configuration with DestinationArn and Format set to a string or struct

let api_gwv2_access_logs_enabled = Resources.*[ Type == "AWS::ApiGatewayV2::Stage"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "API_GWV2_ACCESS_LOGS_ENABLED"
]

rule API_GWV2_ACCESS_LOGS_ENABLED when %api_gwv2_access_logs_enabled !empty {
    %api_gwv2_access_logs_enabled.Properties {
        AccessLogSettings exists
        AccessLogSettings is_struct

        AccessLogSettings {
            DestinationArn exists
            DestinationArn is_string or 
            DestinationArn is_struct
            <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                Violation: Amazon API Gateway V2 stages have access logging enabled
                Fix: In AccessLogSettings, set DestinationArn to the ARN of an Amazon CloudWatch log group and Format to a single line log format configuration.
            >>

            Format exists
            Format is_string or 
            Format is_struct
            <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                Violation: Amazon API Gateway V2 stages have access logging enabled
                Fix: In AccessLogSettings, set DestinationArn to the ARN of an Amazon CloudWatch log group and Format to a single line log format configuration.
            >>
        }
  }
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_SSL_REQUESTS_ONLY
#
# Description:
#   Checks if Amazon S3 buckets have policies that require requests to use Secure Socket Layer (SSL).
#
# Reports on:
#    AWS::S3::BucketPolicy
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 Bucket Policy Document resource present
# b) PASS: when all S3 Bucket Policy Document set to deny if condition SecureTransport not true
# c) FAIL: when all S3 Bucket Policy Document does not have deny on insecure transport actions
# d) SKIP: when metadata includes the suppression for rule S3_BUCKET_SSL_REQUESTS_ONLY

#
# Select all S3 resources from incoming template (payload)
#
let s3_buckets_policies_ssl_requests_only = Resources.*[ Type == 'AWS::S3::BucketPolicy'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_SSL_REQUESTS_ONLY"
]

# Select secure S3 Bucket Policy resources from incoming template
let ssl_secure_bucket_policies = %s3_buckets_policies_ssl_requests_only[
  Properties.PolicyDocument {
    some Statement[*] {
      Effect == 'Deny'
      Condition {
        Bool.'aws:SecureTransport' == false
      }
    }
  }
]

rule S3_BUCKET_SSL_REQUESTS_ONLY when %s3_buckets_policies_ssl_requests_only !empty {
  %ssl_secure_bucket_policies !empty
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: Bucket policies must feature a statement to enforce TLS usage.
    Fix: Set a bucket policy statement to '"Action":"s3:*","Effect":"Deny","Principal":"*","Resource":"*","Condition":{"Bool":{"aws:SecureTransport":false}}' .
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_LOGGING_ENABLED
#
# Description:
#   Checks whether logging is enabled for your S3 buckets.
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources Logging Configuration exists
# c) FAIL: when all S3 resources have Logging Configuration is not set
# d) SKIP: when metadata includes the suppression for rule S3_BUCKET_LOGGING_ENABLED

#
# Select all S3 resources from incoming template (payload)
#

let s3_buckets_bucket_logging_enabled = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_LOGGING_ENABLED"
]

rule S3_BUCKET_LOGGING_ENABLED when %s3_buckets_bucket_logging_enabled  !empty {
  %s3_buckets_bucket_logging_enabled.Properties.LoggingConfiguration exists
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: S3 Bucket Logging needs to be configured to enable logging.
    Fix: Set the S3 Bucket property LoggingConfiguration to start logging into S3 bucket.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_PUBLIC_WRITE_PROHIBITED
#
# Description:
#   Checks if your Amazon S3 buckets do not allow public write access. The rule checks the Block Public
#   Access settings, the bucket policy, and the bucket access control list (ACL).
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources Public Access Block Configuration element is present and properties are set to true
# c) FAIL: when all S3 resources do not have the Public Access Block Configuration element present or all properties set to true
# d) SKIP: when metadata includes the suppression for rule S3_BUCKET_PUBLIC_WRITE_PROHIBITED

#
# Select all S3 resources from incoming template (payload)
#
let s3_buckets_public_write_prohibited = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_PUBLIC_WRITE_PROHIBITED"
]

rule S3_BUCKET_PUBLIC_WRITE_PROHIBITED when %s3_buckets_public_write_prohibited !empty {
  %s3_buckets_public_write_prohibited.Properties.PublicAccessBlockConfiguration exists
  %s3_buckets_public_write_prohibited.Properties.PublicAccessBlockConfiguration.BlockPublicAcls == true
  %s3_buckets_public_write_prohibited.Properties.PublicAccessBlockConfiguration.BlockPublicPolicy == true
  %s3_buckets_public_write_prohibited.Properties.PublicAccessBlockConfiguration.IgnorePublicAcls == true
  %s3_buckets_public_write_prohibited.Properties.PublicAccessBlockConfiguration.RestrictPublicBuckets == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: S3 Bucket Public Write Access controls need to be restricted.
    Fix: Set S3 Bucket PublicAccessBlockConfiguration properties for BlockPublicAcls, BlockPublicPolicy, IgnorePublicAcls, RestrictPublicBuckets parameters to true.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_PUBLIC_READ_PROHIBITED
#
# Description:
#   Checks if your Amazon S3 buckets do not allow public read access. The rule checks the Block Public
#   Access settings, the bucket policy, and the bucket access control list (ACL).
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources Public Access Block Configuration element is present and properties are set to true
# c) FAIL: when all S3 resources do not have the Public Access Block Configuration element present or all properties set to true
# d) SKIP: when metadata includes the suppression for rule S3_BUCKET_PUBLIC_READ_PROHIBITED

#
# Select all S3 resources from incoming template (payload)
#
let s3_bucket_public_read_prohibited = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_PUBLIC_READ_PROHIBITED"
]

rule S3_BUCKET_PUBLIC_READ_PROHIBITED when %s3_bucket_public_read_prohibited !empty {
  %s3_bucket_public_read_prohibited.Properties.PublicAccessBlockConfiguration exists
  %s3_bucket_public_read_prohibited.Properties.PublicAccessBlockConfiguration.BlockPublicAcls == true
  %s3_bucket_public_read_prohibited.Properties.PublicAccessBlockConfiguration.BlockPublicPolicy == true
  %s3_bucket_public_read_prohibited.Properties.PublicAccessBlockConfiguration.IgnorePublicAcls == true
  %s3_bucket_public_read_prohibited.Properties.PublicAccessBlockConfiguration.RestrictPublicBuckets == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: S3 Bucket Public Write Access controls need to be restricted.
    Fix: Set S3 Bucket PublicAccessBlockConfiguration properties for BlockPublicAcls, BlockPublicPolicy, IgnorePublicAcls, RestrictPublicBuckets parameters to true.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_DEFAULT_ENCRYPTION_KMS
#
# Description:
#   Checks whether the Amazon S3 buckets are encrypted with AWS Key Management Service(AWS KMS).
#   The rule is NON_COMPLIANT if the Amazon S3 bucket is not encrypted with AWS KMS key.
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources have ServerSideEncryptionConfiguration property set with values of "aws:kms" or "AES256"
# c) FAIL: when all S3 resources have ServerSideEncryptionConfiguration property not set or values are not "aws:kms" or "AES256"
# d) SKIP: when metadata includes the suppression for rule S3_DEFAULT_ENCRYPTION_KMS

#
# Assignments
#
let s3_buckets_s3_default_encryption = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_DEFAULT_ENCRYPTION_KMS"
]

rule S3_DEFAULT_ENCRYPTION_KMS when %s3_buckets_s3_default_encryption !empty {
  %s3_buckets_s3_default_encryption.Properties.BucketEncryption exists
  %s3_buckets_s3_default_encryption.Properties.BucketEncryption.ServerSideEncryptionConfiguration[*].ServerSideEncryptionByDefault.SSEAlgorithm in ["aws:kms","AES256"]
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: S3 Bucket default encryption must be set.
    Fix: Set the S3 Bucket property BucketEncryption.ServerSideEncryptionConfiguration.ServerSideEncryptionByDefault.SSEAlgorithm to either "aws:kms" or "AES256"
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_VERSIONING_ENABLED
#
# Description:
#   Checks if versioning is enabled for your S3 buckets.
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources Versioning Configuration status is set to Enabled
# c) FAIL: when all S3 resources have Versioning Configuration status property not set or set to Suspended
# d) SKIP: when metadata includes the suppression for rule S3_BUCKET_VERSIONING_ENABLED

#
# Select all S3 resources from incoming template (payload)
#
let s3_buckets_versioning_enabled = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_VERSIONING_ENABLED"
]

rule S3_BUCKET_VERSIONING_ENABLED when %s3_buckets_versioning_enabled !empty {
  %s3_buckets_versioning_enabled.Properties.VersioningConfiguration exists
  %s3_buckets_versioning_enabled.Properties.VersioningConfiguration.Status == 'Enabled'
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: S3 Bucket Versioning must be enabled.
    Fix: Set the S3 Bucket property VersioningConfiguration.Status to 'Enabled' .
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_LEVEL_PUBLIC_ACCESS_PROHIBITED
#
# Description:
#   Checks if Amazon Simple Storage Service (Amazon S3) buckets are publicly accessible.
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources Public Access Block Configuration element is present and properties are set to true
# c) FAIL: when all S3 resources do not have the Public Access Block Configuration element present or all properties set to true
# d) SKIP: when metada has rule suppression for S3_BUCKET_LEVEL_PUBLIC_ACCESS_PROHIBITED

#
# Select all S3 resources from incoming template (payload)
#
let s3_buckets_level_public_access_prohibited = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_LEVEL_PUBLIC_ACCESS_PROHIBITED"
]

rule S3_BUCKET_LEVEL_PUBLIC_ACCESS_PROHIBITED when %s3_buckets_level_public_access_prohibited !empty {
  %s3_buckets_level_public_access_prohibited.Properties.PublicAccessBlockConfiguration exists
  %s3_buckets_level_public_access_prohibited.Properties.PublicAccessBlockConfiguration.BlockPublicAcls == true
  %s3_buckets_level_public_access_prohibited.Properties.PublicAccessBlockConfiguration.BlockPublicPolicy == true
  %s3_buckets_level_public_access_prohibited.Properties.PublicAccessBlockConfiguration.IgnorePublicAcls == true
  %s3_buckets_level_public_access_prohibited.Properties.PublicAccessBlockConfiguration.RestrictPublicBuckets == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: S3 Bucket Public Access controls need to be restricted.
    Fix: Set S3 Bucket PublicAccessBlockConfiguration properties for BlockPublicAcls, BlockPublicPolicy, IgnorePublicAcls, RestrictPublicBuckets parameters to true.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED
#
# Description:
#   Checks if your Amazon S3 bucket either has the Amazon S3 default encryption enabled or that the Amazon S3 bucket policy
#   explicitly denies put-object requests without server side encryption that uses AES-256 or AWS Key Management Service.
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources Bucket Encryption ServerSideEncryptionByDefault is set to either "aws:kms" or "AES256"
# c) FAIL: when all S3 resources have Bucket Encryption ServerSideEncryptionByDefault is not set or does not have "aws:kms" or "AES256" configurations
# d) SKIP: when metadata includes the suppression for rule S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED

#
# Select all S3 resources from incoming template (payload)
#

let s3_buckets_server_side_encryption = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED"
]

rule S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED when %s3_buckets_server_side_encryption !empty {
  %s3_buckets_server_side_encryption.Properties.BucketEncryption exists
  %s3_buckets_server_side_encryption.Properties.BucketEncryption.ServerSideEncryptionConfiguration[*].ServerSideEncryptionByDefault.SSEAlgorithm in ["aws:kms","AES256"]
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: S3 Bucket must enable server-side encryption.
    Fix: Set the S3 Bucket property BucketEncryption.ServerSideEncryptionConfiguration.ServerSideEncryptionByDefault.SSEAlgorithm to either "aws:kms" or "AES256"
  >>
}

## Config Rule Name : s3-bucket-policy-grantee-check
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy-grantee-check.html

# Rule Intent: Checks that the access granted by the Amazon S3 bucket is restricted by any of the AWS principals, federated users, service principals, IP addresses, or VPCs that you provide.

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_DEFAULT_LOCK_ENABLED
#
# Description:
#   Checks whether Amazon S3 bucket has lock enabled, by default
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources ObjectLockEnabled property is set to true
# c) FAIL: when all S3 resources do not have the ObjectLockEnabled property is set to true or is missing
# d) SKIP: when metada has rule suppression for S3_BUCKET_DEFAULT_LOCK_ENABLED

#
# Select all S3 resources from incoming template (payload)
#
let s3_buckets_default_lock_enabled = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_DEFAULT_LOCK_ENABLED"
]

rule S3_BUCKET_DEFAULT_LOCK_ENABLED when %s3_buckets_default_lock_enabled !empty {
  %s3_buckets_default_lock_enabled.Properties.ObjectLockEnabled exists
  %s3_buckets_default_lock_enabled.Properties.ObjectLockEnabled == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: S3 Bucket ObjectLockEnabled must be set to true.
    Fix: Set the S3 property ObjectLockEnabled parameter to true.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_REPLICATION_ENABLED
#
# Description:
#   Checks whether the Amazon S3 buckets have cross-region replication enabled.
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources replication configuration set status is set to Enabled
# c) FAIL: when all S3 resources have Versioning Configuration status property not set or set to Suspended
# d) SKIP: when metadata includes the suppression for rule S3_BUCKET_REPLICATION_ENABLED

#
# Select all S3 resources from incoming template (payload)
#

let s3_buckets_replication_enabled = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_REPLICATION_ENABLED"
]

rule S3_BUCKET_REPLICATION_ENABLED when %s3_buckets_replication_enabled !empty {
  %s3_buckets_replication_enabled.Properties.ReplicationConfiguration exists
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: S3 Bucket replication should be enabled.
    Fix: Set S3 Bucket ReplicationConfiguration to another S3 Bucket.
  >>
    ## TODO regex to identify cross-region
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDFRONT_ACCESSLOGS_ENABLED
#
# Description:
#  Checks if Amazon CloudFront Distributions are configured with access logging.
#
# Reports on:
#    AWS::CloudFront::Distribution
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudFront Distribution Resources
# b) SKIP: when metada has rule suppression for CLOUDFRONT_ACCESSLOGS_ENABLED
# c) FAIL: when all CloudFront Distribution Resources do not have the Logging Configuration element present
# d) PASS: when all CloudFront Distribution Resources have a Logging Configuration element present

#
# Select all CloudFront Distribution Resources from incoming template (payload)
#
let cloudfront_accesslogs_enabled_resources = Resources.*[ Type == 'AWS::CloudFront::Distribution'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDFRONT_ACCESSLOGS_ENABLED"
]

rule CLOUDFRONT_ACCESSLOGS_ENABLED when %cloudfront_accesslogs_enabled_resources !empty {
  %cloudfront_accesslogs_enabled_resources.Properties.DistributionConfig.Logging exists
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudFront Distributions need to be configured to log informaiton about requests the Distribution receives.
    Fix: Set the CloudFront Distribution DistributionConfig.Logging.Bucket property to an S3 bucket you own that has been configured to receive CloudFront standard logs.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDFRONT_CUSTOM_SSL_CERTIFICATE
#
# Description:
#  Checks if Amazon CloudFront distributions are associated with either WAF or WAFv2 web access control lists (ACLs).
#
# Reports on:
#    AWS::CloudFront::Distribution
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudFront Distribution Resources
# b) SKIP: when metadata has rule suppression for CLOUDFRONT_CUSTOM_SSL_CERTIFICATE
# c) FAIL: when CloudFront Distribution Resources do not have the Viewer Certificate configuration present
# d) FAIL: when CloudFront Distribution Resources have the Viewer Certificate configuration present and CloudFront Default Certificate is set to true
# e) PASS: when all CloudFront Distribution Resources have a Viewer Certificate configuration present with an AcmCertificateArn or IamCertificateId

#
# Select all CloudFront Distribution Resources from incoming template (payload)
#
let cloudfront_custom_ssl_certificate_resources = Resources.*[ Type == 'AWS::CloudFront::Distribution'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDFRONT_CUSTOM_SSL_CERTIFICATE"
]

rule CLOUDFRONT_CUSTOM_SSL_CERTIFICATE when %cloudfront_custom_ssl_certificate_resources !empty {
  %cloudfront_custom_ssl_certificate_resources.Properties.DistributionConfig {
    # Scenario c)
    ViewerCertificate exists
    # Scenario d)
    ViewerCertificate.CloudFrontDefaultCertificate not exists or
    ViewerCertificate.CloudFrontDefaultCertificate == false
    # Scenario e)
    ViewerCertificate.AcmCertificateArn exists or
    ViewerCertificate.IamCertificateId exists
    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
      Violation: CloudFront Distributions need to to use a custom SSL/TLS certificate.
      Fix: Set the AcmCertificateArn or IamCertificateId properties in the CloudFront Distribution DistributionConfig.ViewerCertificate configuration.
    >>
  }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDFRONT_ORIGIN_FAILOVER_ENABLED
#
# Description:
#  Checks if Amazon CloudFront Distribution is configured with an Origin Group that contains two Origin Group Members.
#
# Reports on:
#    AWS::CloudFront::Distribution
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudFront Distribution Resources
# b) SKIP: when metadata has rule suppression for CLOUDFRONT_ORIGIN_FAILOVER_ENABLED
# c) FAIL: when CloudFront Distribution Resources do not include an Origin Group configuration
# d) FAIL: when CloudFront Distribution Resources include an Origin Group configuration without any Origin Groups configured
# e) FAIL: when CloudFront Distribution Resources include Origin Groups with < 2 Origin Group Members
# f) PASS: when CloudFront Distribution Resources include Origin Groups with 2 Origin Group Members

#
# Select all CloudFront Distribution Resources from incoming template (payload)
#
let cloudfront_origin_failover_enabled_resources = Resources.*[ Type == 'AWS::CloudFront::Distribution'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDFRONT_ORIGIN_FAILOVER_ENABLED"
]

rule CLOUDFRONT_ORIGIN_FAILOVER_ENABLED when %cloudfront_origin_failover_enabled_resources !empty {
  %cloudfront_origin_failover_enabled_resources.Properties.DistributionConfig {
    # Scenario c)
    OriginGroups exists
    # Scenario d)
    OriginGroups.Quantity >= 1
    OriginGroups.Items.* {
        # Scenarios e) and f)
        Members.Quantity == 2
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
          Violation: CloudFront Distributions are configured with origin failover
          Fix: Set the SslSupportMethod to 'sni-only' in the CloudFront Distribution DistributionConfig.ViewerCertificate configuration.
        >>
    }

  }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDFRONT_SNI_ENABLED
#
# Description:
#  Checks if Amazon CloudFront distributions are configured to use SNI to serve HTTPS requests.
#
# Reports on:
#    AWS::CloudFront::Distribution
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudFront Distribution Resources
# b) SKIP: when metadata has rule suppression for CLOUDFRONT_SNI_ENABLED
# c) FAIL: when CloudFront Distribution Resources do not have a Viewer Certificate configuration
# d) FAIL: when CloudFront Distribution Resources have a Viewer Certificate configuration and a CloudFront Default Certificate
# e) FAIL: when CloudFront Distribution Resources have SSL Support Method set to 'vip'
# f) PASS: when CloudFront Distribution Resources have SSL Support Method set to 'sni-only'

#
# Select all CloudFront Distribution Resources from incoming template (payload)
#
let cloudfront_sni_enabled_resources = Resources.*[ Type == 'AWS::CloudFront::Distribution'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDFRONT_SNI_ENABLED"
]

rule CLOUDFRONT_SNI_ENABLED when %cloudfront_sni_enabled_resources !empty {
  %cloudfront_sni_enabled_resources.Properties.DistributionConfig {
    # Scenario c)
    ViewerCertificate exists
    # Scenario d)
    ViewerCertificate.CloudFrontDefaultCertificate not exists or
    ViewerCertificate.CloudFrontDefaultCertificate == false
    # Scenarios e) and f)
    ViewerCertificate.SslSupportMethod exists
    ViewerCertificate.SslSupportMethod not in ['vip']
    ViewerCertificate.SslSupportMethod == 'sni-only'
    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
      Violation: CloudFront Distributions are configured to use SNI to serve HTTPS requests.
      Fix: Set the SslSupportMethod to 'sni-only' in the CloudFront Distribution DistributionConfig.ViewerCertificate configuration.
    >>
  }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDFRONT_ORIGIN_ACCESS_IDENTITY_ENABLED
#
# Description:
#  Checks if Amazon CloudFront distributions backed by S3 are configured with an Origin Access Identity (OAI).
#
# Reports on:
#    AWS::CloudFront::Distribution
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudFront Distribution Resources
# b) SKIP: when metadata has rule suppression for CLOUDFRONT_ORIGIN_ACCESS_IDENTITY_ENABLED
# c) FAIL: when CloudFront Distribution Resources have a Legacy S3 Origin configuration present
# d) FAIL: when CloudFront Distribution Resources have an S3 Origin configured without an Origin Access Identity (OAI)
# e) PASS: when CloudFront Distribution Resources do not have an S3 Origin configured
# f) PASS: when CloudFront Distribution Resources have an S3 Origin configured with an Origin Access Identity (OAI)

#
# Select all CloudFront Distribution Resources from incoming template (payload)
#
let cloudfront_origin_access_identity_enabled_resources = Resources.*[ Type == 'AWS::CloudFront::Distribution'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDFRONT_ORIGIN_ACCESS_IDENTITY_ENABLED"
]

rule CLOUDFRONT_ORIGIN_ACCESS_IDENTITY_ENABLED when %cloudfront_origin_access_identity_enabled_resources !empty {
  let doc = this  
  %cloudfront_origin_access_identity_enabled_resources.Properties.DistributionConfig {
    S3Origin not exists

    when Origins exists
         Origins is_list
         Origins not empty {

      Origins [
        DomainName == /(.*)\.s3(-external-\d|[-\.][a-z]*-[a-z]*-[0-9])?\.amazonaws\.com(\.cn)?$/ or
        DomainName {
          'Fn::GetAtt' {
              this is_list
              this[1] == "DomainName" or
              this[1] == "RegionalDomainName"
              
              let resource_logical_name = this[0]
              let referenced_resource = %doc.Resources[ keys == %resource_logical_name ]            
              
              %referenced_resource not empty
              %referenced_resource {
                  Type == "AWS::S3::Bucket"    
              }
          }
        }
      ] {
        S3OriginConfig.OriginAccessIdentity exists
        S3OriginConfig.OriginAccessIdentity != ""
        
        S3OriginConfig.OriginAccessIdentity is_string or 
        S3OriginConfig.OriginAccessIdentity is_struct
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
          Violation: CloudFront Distributions backed by S3 must be configured with an Origin Access Identity (OAI).
          Fix: Set the S3OriginConfig.OriginAccessIdentity property for CloudFront Distribution Origins backed by S3.
        >>
      }
    }
  } 
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDFRONT_VIEWER_POLICY_HTTPS
#
# Description:
#  Checks whether your Amazon CloudFront distributions use HTTPS (directly or via a redirection).
#
# Reports on:
#    AWS::CloudFront::Distribution
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudFront Distribution Resources
# b) SKIP: when metadata has rule suppression for CLOUDFRONT_VIEWER_POLICY_HTTPS
# c) SKIP: when no CloudFront Distribution Cache Behaviors or Default Cache Behaviors are provided
# d) FAIL: when CloudFront Distribution Default Cache Behavior Viewer Protocol Policies are configured to allow all (HTTP & HTTPS)
# e) FAIL: when one or more CloudFront Distribution Cache Behavior Viewer Protocol Policies are configured to allow all (HTTP & HTTPS)
# f) PASS: when CloudFront Distribution Default Cache Behavior Viewer Protocol Policies are configured with HTTPS (directly or via a redirection)
# g) PASS: when all CloudFront Distribution Cache Behavior Viewer Protocol Policies are configured with HTTPS (directly or via a redirection)

#
# Select all CloudFront Distribution Resources from incoming template (payload)
#
let cloudfront_viewer_policy_https_resources = Resources.*[ Type == 'AWS::CloudFront::Distribution'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDFRONT_VIEWER_POLICY_HTTPS"
]

rule CLOUDFRONT_VIEWER_POLICY_HTTPS when %cloudfront_viewer_policy_https_resources !empty {
  %cloudfront_viewer_policy_https_resources.Properties.DistributionConfig {

    when DefaultCacheBehavior exists {
        # Scenario c)
        DefaultCacheBehavior.ViewerProtocolPolicy != "allow-all"
        DefaultCacheBehavior.ViewerProtocolPolicy in ["redirect-to-https", "https-only"]
        # Scenario e)
    }

    when CacheBehaviors exists
         CacheBehaviors not empty {
      CacheBehaviors.*{
          # Scenario d)
          ViewerProtocolPolicy != "allow-all"
          # Scenario f)
          ViewerProtocolPolicy in ["redirect-to-https", "https-only"]
          <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
            Violation: Amazon CloudFront distributions must use HTTPS (directly or via a redirection).
            Fix: Set the ViewerProtocolPolicy in DefaultCacheBehavior or CacheBehaviors to one of "redirect-to-https" or "https-only".
          >>
      }
    }

  }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDFRONT_DEFAULT_ROOT_OBJECT_CONFIGURED
#
# Description:
#  Checks if an Amazon CloudFront distribution is configured to return a specific object that is the default root object.
#
# Reports on:
#    AWS::CloudFront::Distribution
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudFront Distribution Resources
# b) SKIP: when metadata has rule suppression for CLOUDFRONT_DEFAULT_ROOT_OBJECT_CONFIGURED
# c) FAIL: when CloudFront Distribution Resources do not have a Default Root Object configured
# d) FAIL: when CloudFront Distribution Resources have an empty Default Root Object configured
# e) PASS: when all CloudFront Distribution Resources have a Default Root Object configured

#
# Select all CloudFront Distribution Resources from incoming template (payload)
#
let cloudfront_default_root_object_configured_resources = Resources.*[ Type == 'AWS::CloudFront::Distribution'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDFRONT_DEFAULT_ROOT_OBJECT_CONFIGURED"
]

rule CLOUDFRONT_DEFAULT_ROOT_OBJECT_CONFIGURED when %cloudfront_default_root_object_configured_resources !empty {
  # Scenario c)
  %cloudfront_default_root_object_configured_resources.Properties.DistributionConfig.DefaultRootObject exists
  # Scenarios d) and e)
  %cloudfront_default_root_object_configured_resources.Properties.DistributionConfig.DefaultRootObject != ""
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudFront Distributions must be configured to return a default root object.
    Fix: Set the CloudFront Distribution DistributionConfig.DefaultRootObject property to the object that you want CloudFront to request from your origin for requests to the root URL of your distribution.
  >>
}


#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    SNS_ENCRYPTED_KMS
#
# Description:
#   Checks if Amazon SNS topic is encrypted with AWS Key Management Service (AWS KMS)
#
# Reports on:
#    AWS::SNS::Topic
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no SNS Topics present
# b) SKIP: when metada has rule suppression for SNS_ENCRYPTED_KMS
# c) FAIL: when SNS topics are present, they are not encrypted with KMS
# d) PASS: when SNS topics are present, they are encrypted with KMS

#
# Select all AWS::SNS::Topic resources from incoming template (payload)
#

let sns_encrypted_kms = Resources.*[ Type == "AWS::SNS::Topic"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SNS_ENCRYPTED_KMS"
]


rule SNS_ENCRYPTED_KMS when %sns_encrypted_kms !empty {
  %sns_encrypted_kms.Properties.KmsMasterKeyId exists
	<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
		Violation: Amazon SNS Topics are configured with a Key Management Service (KMS) key 
		Fix: Set the KmsMasterKeyId property
	>>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   ALB_HTTP_DROP_INVALID_HEADER_ENABLED
#
# Description:
#   Checks if rule evaluates AWS Application Load Balancers (ALB) to ensure they are configured to drop http headers.
#
# Reports on:
#   AWS::ElasticLoadBalancingV2::LoadBalancer
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing V2 Resources of type 'application'
# b) SKIP: when metadata has rule suppression for ALB_HTTP_DROP_INVALID_HEADER_ENABLED
# c) FAIL: when 'LoadBalancerAttributes' have not been provided
# d) FAIL: when 'LoadBalancerAttributes' have been provided without the 'routing.http.drop_invalid_header_fields.enabled' attribute
# e) FAIL: when 'LoadBalancerAttributes' have been provided with the 'routing.http.drop_invalid_header_fields.enabled' attribute set to 'false'
# f) PASS: when 'LoadBalancerAttributes' have been provided with the 'routing.http.drop_invalid_header_fields.enabled' attribute set to 'true'

#
# Select all Elastic Load Balancing V2 Resources from incoming template of type 'application' (payload)
#
let alb_http_drop_invalid_header_enabled_resources = Resources.*[ Type == 'AWS::ElasticLoadBalancingV2::LoadBalancer'
  Properties.Type == "application"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ALB_HTTP_DROP_INVALID_HEADER_ENABLED"
]

rule ALB_HTTP_DROP_INVALID_HEADER_ENABLED when %alb_http_drop_invalid_header_enabled_resources !empty {
    %alb_http_drop_invalid_header_enabled_resources.Properties {
        LoadBalancerAttributes exists
        LoadBalancerAttributes is_list
        LoadBalancerAttributes not empty
        
        some LoadBalancerAttributes[*] {
            Key == "routing.http.drop_invalid_header_fields.enabled"
            Value == true OR
            Value == "true"
            <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                Violation: AWS Application Load Balancers (ALB) must be configured to drop invalid HTTP headers.
                Fix: Set the 'LoadBalancerAttribute' 'routing.http.drop_invalid_header_fields.enabled' to 'true'
            >>
        }	
    }
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   ELB_DELETION_PROTECTION_ENABLED
#
# Description:
#   This rule will check to see if cross-zone load balancing is enabled for the Classic Load Balancer.
#
# Reports on:
#   AWS::ElasticLoadBalancingV2::LoadBalancer
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing Resources
# b) SKIP: when metadata has rule suppression for ELB_DELETION_PROTECTION_ENABLED
# c) FAIL: when 'LoadBalancerAttributes' has not been specified
# d) FAIL: when 'LoadBalancerAttributes' has been specified and the attribute 'deletion_protection.enabled' has not been provided
# d) FAIL: when 'LoadBalancerAttributes' has been specified with the attribute 'deletion_protection.enabled' set to false
# d) PASS: when 'LoadBalancerAttributes' has been specified with the attribute 'deletion_protection.enabled' set to true

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elb_deletion_protection_enabled_resources = Resources.*[ Type == 'AWS::ElasticLoadBalancingV2::LoadBalancer'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELB_DELETION_PROTECTION_ENABLED"
]

rule ELB_DELETION_PROTECTION_ENABLED when %elb_deletion_protection_enabled_resources !empty {
    %elb_deletion_protection_enabled_resources.Properties {
        LoadBalancerAttributes exists
        LoadBalancerAttributes is_list
        LoadBalancerAttributes not empty
        
        some LoadBalancerAttributes[*] {
            Key == "deletion_protection.enabled"
            Value == true OR
            Value == "true"
            <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                Violation: AWS Application Load Balancers (ALB) must be configured with deletion protection.
                Fix: Set the 'LoadBalancerAttribute' 'deletion_protection.enabled' to 'true'
            >>
        }
    }
}

## Config Rule Name : alb-waf-enabled
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/alb-waf-enabled.html"


# Rule Intent: Checks if HTTP to HTTPS redirection is configured on all HTTP listeners of Application Load Balancers.

# Expectations:
# a) SKIP: when there are no ALB resources present
# b) PASS: when one or more HTTP listeners have forwarding to an HTTPS listener
# c) FAIL: when one of more HTTP listeners have forwarding to an HTTP listener instead of redirection.
# d) FAIL: when one or more HTTP listeners of Application Load Balancer do not have HTTP to HTTPS redirection configured.



#
# Select all ALB resources from incoming template (payload)
#

## Config Rule Name : elbv2-acm-certificate-required
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/elbv2-acm-certificate-required.html"
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   ELBV2_ACM_CERTIFICATE_REQUIRED
#
# Description:
#   Checks if Application Load Balancers and Network Load Balancer HTTPS or TLS listeners are configured to use certificates from AWS Certificate Manager (ACM)
#
# Reports on:
#   AWS::ElasticLoadBalancingV2::Listener
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing V2 Listener Resources
# b) SKIP: when metadata has rule suppression for ELB_ACM_CERTIFICATE_REQUIRED
# c) SKIP: when there are no HTTPS or TLS Listeners
# d) FAIL: when the Certificate in 'Certificates' is not an ACM certificate for HTTPS or TLS Listeners
# e) PASS: when the Certificate in 'Certificates' is an ACM certificate for HTTPS or TLS Listeners

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elbv2_acm_certificate_required_resources = Resources.*[ Type == 'AWS::ElasticLoadBalancingV2::Listener'
  # Scenario c)
  Properties.Protocol == 'HTTPS' or
  Properties.Protocol == 'TLS'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELBV2_ACM_CERTIFICATE_REQUIRED"
]

rule ELBV2_ACM_CERTIFICATE_REQUIRED when %elbv2_acm_certificate_required_resources !empty {
    let doc = this 
    %elbv2_acm_certificate_required_resources.Properties {
        # Scenarios d) and e)
        Certificates exists
        Certificates is_list
        Certificates not empty

        Certificates[*] {
            CertificateArn exists
            CertificateArn == /arn:aws[a-z0-9\-]*:acm:[a-z0-9\-]+:\d{12}:certificate\/[\w\-]{1,64}/ or 
            CertificateArn {
                Ref {
                    let resource_logical_name = this
                    let referenced_resource = %doc.Resources[ keys == %resource_logical_name ]
                    %referenced_resource not empty
                    %referenced_resource {
                        Type == "AWS::CertificateManager::Certificate"
                        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                            Violation: ELBv2 Listeners need to use HTTPS/SSL certificates provided by AWS Certificate Manager (ACM).
                            Fix: Set the ELBV2 Certificates.*.CertificateArn property to the ARN of an ACM Certificate.
                        >>
                    }
                }
            }
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    API_GW_CACHE_ENABLED_AND_ENCRYPTED
#
# Description:
#    Checks that all methods in Amazon API Gateway stages have cache enabled and cache encrypted.
#
# Reports on:
#    AWS::ApiGateway::Stage
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no API GW Stage Methods present
# b) PASS: when all API Stage Method has caching enabled and encrypted
# c) FAIL: when API Stage Method does not have caching enabled and encrypted
# d) SKIP: when metadata includes the suppression for rule API_GW_CACHE_ENABLED_AND_ENCRYPTED

let api_gw_cache_enabled_encrypted = Resources.*[ Type == 'AWS::ApiGateway::Stage'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "API_GW_CACHE_ENABLED_AND_ENCRYPTED"
]

rule API_GW_CACHE_ENABLED_AND_ENCRYPTED when %api_gw_cache_enabled_encrypted !empty {
  when %api_gw_cache_enabled_encrypted.Properties.MethodSettings exists {
    %api_gw_cache_enabled_encrypted.Properties.MethodSettings.*.CacheDataEncrypted == true
    %api_gw_cache_enabled_encrypted.Properties.MethodSettings.*.CachingEnabled == true
    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
      Violation: API Gateway Stage Method not set with caching and caching encrypted
      Fix: API GW Stage Method property CacheDataEncrypted and CachingEnabled set to true
    >>
  }
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    API_GW_EXECUTION_LOGGING_ENABLED
#
# Description:
#    Checks that all methods in Amazon API Gateway stage has logging enabled. The rule is NON_COMPLIANT if logging is not enabled.
#
# Reports on:
#    AWS::ApiGateway::Stage
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no API GW Stage present
# b) PASS: when all API GW Stage Methods have logginglevel set to "ERROR" OR "INFO"
# c) FAIL: when API GW Domain Names doesn't have logginglevel set to "ERROR" OR "INFO"
# d) SKIP: when metadata includes the suppression for rule API_GW_EXECUTION_LOGGING_ENABLED

let api_gw_execution_logging_enabled = Resources.*[ Type == 'AWS::ApiGateway::Stage'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "API_GW_EXECUTION_LOGGING_ENABLED"
]

rule API_GW_EXECUTION_LOGGING_ENABLED when %api_gw_execution_logging_enabled !empty {
  when %api_gw_execution_logging_enabled.Properties.MethodSettings !empty {
    %api_gw_execution_logging_enabled.Properties.MethodSettings.*.LoggingLevel == "ERROR" OR
    %api_gw_execution_logging_enabled.Properties.MethodSettings.*.LoggingLevel == "INFO"
    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
      Violation: Logging Level for API GW Method Setting not set
      Fix: API GW Stage Method Setting logging level must be set to "ERROR" or "INFO"
    >>
  }
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    API_GW_ENDPOINT_TYPE_CHECK
#
# Description:
#   Checks if Amazon API Gateway APIs are of the type specified in the rule parameter endpointConfigurationType
#
# Reports on:
#    AWS::ApiGateway::DomainName
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no API GW present
# b) PASS: when all API GW have endpoint configuration set to "REGIONAL", "PRIVATE", and/or "EDGE"
# c) FAIL: when all API GW does not have endpoint configuration set to "REGIONAL", "PRIVATE", and/or "EDGE"
# d) SKIP: when metadata includes the suppression for rule API_GW_ENDPOINT_TYPE_CHECK

#
# Select all API GW Method resources from incoming template (payload)
#
let api_gw_resources_type_check = Resources.*[ Type == 'AWS::ApiGateway::DomainName'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "API_GW_ENDPOINT_TYPE_CHECK"
]

rule API_GW_ENDPOINT_TYPE_CHECK when %api_gw_resources_type_check !empty {
  some %api_gw_resources_type_check.Properties.EndpointConfiguration.Types IN ["REGIONAL", "PRIVATE", "EDGE"]
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: EndpointConfiguration must contain "REGIONAL", "PRIVATE", and/or "EDGE"
    Fix: Set EndpointConfiguration Type to "REGIONAL", "PRIVATE", and/or "EDGE"
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    API_GW_DOMAIN_DENY_NON_TLS_TRAFFIC
#
# Description:
#   All API GW Domain Name Resources must deny non-TLS traffic
#
# Reports on:
#    AWS::ApiGateway::DomainName
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no API GW Methods present
# b) PASS: when all API GW Domain Names have a security policy configured to deny non-TLS traffic
# c) FAIL: when API GW Domain Names doesn't have a security policy configured to deny non-TLS traffic
# d) SKIP: when metadata includes the suppression for rule API_GW_DOMAIN_DENY_NON_TLS_TRAFFIC

#
# Select all API GW Method resources from incoming template (payload)
#
let aws_apigw_domain_resources_tls_traffic = Resources.*[ Type == 'AWS::ApiGateway::DomainName'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "API_GW_DOMAIN_DENY_NON_TLS_TRAFFIC"
]

rule API_GW_DOMAIN_DENY_NON_TLS_TRAFFIC when %aws_apigw_domain_resources_tls_traffic !empty {
	%aws_apigw_domain_resources_tls_traffic.Properties.SecurityPolicy == "TLS_1_2"
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: API Gateway DomainName - SecurityPolicy must use TLS 1.2
    Fix: Set the SecurityPolicy property parameter to "TLS_1_2".
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    REDSHIFT_CLUSTER_PUBLIC_ACCESS_CHECK
#
# Description:
#   Redshift cluster should not be publicly accessible on the internet.
#
# Reports on:
#    AWS::EKS::Cluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there is no Redshift cluster present
# b) PASS: when Redshift Cluster resources do not have the publiclyAccessible property set (default false)
# c) PASS: when Redshift Cluster resources have the PubliclyAccessible property set to false
# d) FAIL: when any Redshift Cluster resources have the PubliclyAccessible property set to true
# e) SKIP: when metada includes the suppression for rule REDSHIFT_CLUSTER_PUBLIC_ACCESS_CHECK

#
# Select all Redshift cluster resources from incoming template
#

let aws_redshift_clusters_resources_public_access_check = Resources.*[ Type == 'AWS::Redshift::Cluster'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "REDSHIFT_CLUSTER_PUBLIC_ACCESS_CHECK"
]


rule REDSHIFT_CLUSTER_PUBLIC_ACCESS_CHECK when %aws_redshift_clusters_resources_public_access_check !empty {
    %aws_redshift_clusters_resources_public_access_check.Properties.PubliclyAccessible  not exists or
    %aws_redshift_clusters_resources_public_access_check.Properties.PubliclyAccessible == false

  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: Redshift cluster should not be available to public.
    Fix: Set the Redshift property PubliclyAccessible parameter to false.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    REDSHIFT_BACKUP_ENABLED
#
# Description:
#    Checks that Amazon Redshift automated snapshots are enabled for clusters. 
#
# Reports on:
#   AWS::Redshift::Cluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no Redshift Cluster resource present
# b) PASS: when Redshift Cluster resources don't have the AutomatedSnapshotRetentionPeriod property set (default retention period is 1 day)
# c) PASS: when Redshift Cluster resources have the AutomatedSnapshotRetentionPeriod property set to greater than 0 
# d) FAIL: when any Redshift Cluster resources have the AutomatedSnapshotRetentionPeriod property set to 0 
# e) SKIP: when metadata includes the suppression for rule REDSHIFT_BACKUP_ENABLED

#
# Select all Redshift Cluster resources from incoming template (payload)
#
let redhshift_backup_enabled_clusters = Resources.*[ Type == 'AWS::Redshift::Cluster' 
	Metadata.guard.SuppressedRules not exists or
    Metadata.guard.SuppressedRules.* != "REDSHIFT_BACKUP_ENABLED"
]

rule REDSHIFT_BACKUP_ENABLED when %redhshift_backup_enabled_clusters !empty {
    %redhshift_backup_enabled_clusters.Properties.AutomatedSnapshotRetentionPeriod not exists
    or %redhshift_backup_enabled_clusters.Properties.AutomatedSnapshotRetentionPeriod > 0
    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
			Violation: Amazon Redshift automated snapshots must be enabled for clusters
			Fix: Either remove the AutomatedSnapshotRetentionPeriod property (default retention period is 1 day)
            Or set the AutomatedSnapshotRetentionPeriod property to an integer greater than 0 
    >>
}
####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    REDSHIFT_CLUSTER_MAINTENANCESETTINGS_CHECK
#
# Description:
#    Checks whether Amazon Redshift clusters have the specified maintenance settings (AllowVersionUpgrade, PreferredMaintenanceWindow, AutomatedSnapshotRetentionPeriod) 
#
# Reports on:
#   AWS::Redshift::Cluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no Redshift Cluster resource present
# b) PASS: when Redshift Cluster resources have properties PreferredMaintenanceWindow set, AllowVersionUpgrade either not set (default true) or set to true, and AutomatedSnapshotRetentionPeriod either not set (default 1 day) or set to greated than 0. 
# c) FAIL: when any Redshift Cluster resources do not have PreferredMaintenanceWindow property set
# d) FAIL: when any Redshift Cluster resources have AllowVersionUpgrade property set to false 
# e) FAIL: when any Redshift Cluster resources have AutomatedSnapshotRetentionPeriod property set to 0
# f) SKIP: when metadata includes the suppression for rule REDSHIFT_CLUSTER_MAINTENANCESETTINGS_CHECK

#
# Select all Redshift Cluster resources from incoming template (payload)
#
let redhshift_clusters_maintenancesettings_check = Resources.*[ Type == 'AWS::Redshift::Cluster' 
	Metadata.guard.SuppressedRules not exists or
    Metadata.guard.SuppressedRules.* != "REDSHIFT_CLUSTER_MAINTENANCESETTINGS_CHECK"
]

rule REDSHIFT_CLUSTER_MAINTENANCESETTINGS_CHECK when %redhshift_clusters_maintenancesettings_check !empty {
    %redhshift_clusters_maintenancesettings_check.Properties.PreferredMaintenanceWindow exists
    
    %redhshift_clusters_maintenancesettings_check.Properties.AllowVersionUpgrade not exists or 
    %redhshift_clusters_maintenancesettings_check.Properties.AllowVersionUpgrade == true


    %redhshift_clusters_maintenancesettings_check.Properties.AutomatedSnapshotRetentionPeriod not exists or 
    %redhshift_clusters_maintenancesettings_check.Properties.AutomatedSnapshotRetentionPeriod > 0

    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
			Violation: Amazon Redshift maintenance settings must be configured
			Fix: set the PreferredMaintenanceWindow property, remove the AllowVersionUpgrade property (default true) or set it to true, and remove the AutomatedSnapshotRetentionPeriod property (default 1 day) or set it to greated than 0. 
    >>
}
####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    REDSHIFT_ENHANCED_VPC_ROUTING_ENABLED
#
# Description:
#    Checks if Amazon Redshift cluster has 'enhancedVpcRouting' enabled.
#
# Reports on:
#   AWS::Redshift::Cluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no Redshift Cluster resource present
# b) PASS: when Redshift Cluster resources have property EnhancedVpcRouting set to true 
# c) FAIL: when any Redshift Cluster resources do not have EnhancedVpcRouting property set (defualt false)
# d) FAIL: when any Redshift Cluster resources have EnhancedVpcRouting property set to false 
# e) SKIP: when metadata includes the suppression for rule REDSHIFT_ENHANCED_VPC_ROUTING_ENABLED

#
# Select all Redshift Cluster resources from incoming template (payload)
#
let redhshift_enhanced_vpc_routing_enabled_clusters = Resources.*[ Type == 'AWS::Redshift::Cluster' 
	Metadata.guard.SuppressedRules not exists or
    Metadata.guard.SuppressedRules.* != "REDSHIFT_ENHANCED_VPC_ROUTING_ENABLED"
]

rule REDSHIFT_ENHANCED_VPC_ROUTING_ENABLED when %redhshift_enhanced_vpc_routing_enabled_clusters !empty {
    %redhshift_enhanced_vpc_routing_enabled_clusters.Properties.EnhancedVpcRouting == true

    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
			Violation: Enhanced VPC Routing must be enabled on Redshift clusters 
			Fix: set the EnhancedVpcRouting property to true
    >>
}
####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    REDSHIFT_CLUSTER_CONFIGURATION_CHECK
#
# Description:
#    Checks whether Amazon Redshift clusters have the specified settings (Encrypted Only)  
#
# Reports on:
#   AWS::Redshift::Cluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no Redshift Cluster resource present
# b) PASS: when Redshift Cluster resources have the Encrypted property set to true
# c) FAIL: when any Redshift Cluster resources do not have Encrypted property set (default false)
# d) FAIL: when any Redshift Cluster resources have Encrypted property set to false 
# e) SKIP: when metadata includes the suppression for rule REDSHIFT_CLUSTER_CONFIGURATION_CHECK

#
# Select all Redshift Cluster resources from incoming template (payload)
#
let redhshift_clusters_configuration_check = Resources.*[ Type == 'AWS::Redshift::Cluster' 
	Metadata.guard.SuppressedRules not exists or
    Metadata.guard.SuppressedRules.* != "REDSHIFT_CLUSTER_CONFIGURATION_CHECK"
]

rule REDSHIFT_CLUSTER_CONFIGURATION_CHECK when %redhshift_clusters_configuration_check !empty {
    %redhshift_clusters_configuration_check.Properties.Encrypted == true

    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
			Violation: Amazon Redshift configuration should have encryption enabled
			Fix: Set the Encrypted property to true 
    >>
}
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    SAGEMAKER_NOTEBOOK_INSTANCE_KMS_KEY_CONFIGURED
#
# Description:
#   Checks whether AWS Key Management Service (KMS) key is configured for an Amazon SageMaker notebook instance.
#
# Reports on:
#    AWS::SageMaker::NotebookInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when Sagemaker Notebook Instance resource not present
# b) SKIP: when metada has rule suppression for SAGEMAKER_NOTEBOOK_INSTANCE_KMS_KEY_CONFIGURED
# c) FAIL: when all Sagemaker Notebook Instance resources KmsKeyId property does not exist
# d) PASS: when all Sagemaker Notebook Instance resources KmsKeyId property is set

#
# Select all AWS::SageMaker::NotebookInstance resources from incoming template (payload)
#

let sagemaker_notebook_instance_kms_key_configured = Resources.*[ Type == "AWS::SageMaker::NotebookInstance"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SAGEMAKER_NOTEBOOK_INSTANCE_KMS_KEY_CONFIGURED"
]

rule SAGEMAKER_NOTEBOOK_INSTANCE_KMS_KEY_CONFIGURED when %sagemaker_notebook_instance_kms_key_configured !empty {
	%sagemaker_notebook_instance_kms_key_configured.Properties.KmsKeyId exists
	<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
		Violation: Amazon SageMaker Notebook instances are configured with a Key Management Service (KMS) key 
		Fix: Set the KmsKeyId property
	>>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    SAGEMAKER_ENDPOINT_CONFIGURATION_KMS_KEY_CONFIGURED
#
# Description:
#   Checks whether AWS Key Management Service (KMS) key is configured for an Amazon SageMaker endpoint configuration.
#
# Reports on:
#    AWS::SageMaker::EndpointConfig
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when Sagemaker EndpointConfig resource not present
# b) SKIP: when metada has rule suppression for SAGEMAKER_ENDPOINT_CONFIGURATION_KMS_KEY_CONFIGURED
# c) FAIL: when all Sagemaker EndpointConfig resources KmsKeyId property does not exist
# d) PASS: when all Sagemaker EndpointConfig resources KmsKeyId property is set

#
# Select all AWS::SageMaker::EndpointConfig resources from incoming template (payload)
#
let sagemaker_endpoint_configuration_kms_key_configured = Resources.*[ Type == "AWS::SageMaker::EndpointConfig"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SAGEMAKER_ENDPOINT_CONFIGURATION_KMS_KEY_CONFIGURED"
]

rule SAGEMAKER_ENDPOINT_CONFIGURATION_KMS_KEY_CONFIGURED when %sagemaker_endpoint_configuration_kms_key_configured !empty {
	%sagemaker_endpoint_configuration_kms_key_configured.Properties.KmsKeyId exists
	<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
		Violation: Amazon SageMaker endpoints are configured with a Key Management Service (KMS) key 
		Fix: Set the KmsKeyId property
	>>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    SAGEMAKER_NOTEBOOK_NO_DIRECT_INTERNET_ACCESS
#
# Description:
#   Checks whether AWS Key Management Service (KMS) key is configured for an Amazon SageMaker endpoint configuration.
#
# Reports on:
#    AWS::SageMaker::NotebookInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when Sagemaker Notebook Instance resource not present
# b) PASS: when all Sagemaker Notebook Instance resources KmsKeyId property is set
# c) FAIL: when all Sagemaker Notebook Instance resources KmsKeyId property does not exist
# d) SKIP: when metada has rule suppression for SAGEMAKER_NOTEBOOK_NO_DIRECT_INTERNET_ACCESS

#
# Select all AWS::SageMaker::NotebookInstance resources from incoming template (payload)
#

let sagemaker_notebookinstances_directaccess = Resources.*[ Type == "AWS::SageMaker::NotebookInstance"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SAGEMAKER_NOTEBOOK_NO_DIRECT_INTERNET_ACCESS"
]

rule SAGEMAKER_NOTEBOOK_NO_DIRECT_INTERNET_ACCESS when %sagemaker_notebookinstances_directaccess !empty {
	%sagemaker_notebookinstances_directaccess.Properties.DirectInternetAccess exists
	%sagemaker_notebookinstances_directaccess.Properties.DirectInternetAccess == "Disabled"
	<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
		Violation: Amazon SageMaker Notebook instance should not have direct internet access
		Fix: Set the property DirectInternetAccess to "Disabled" and provide a value for SubnetId property
	>>
}

    ## Config Rule Name : dynamodb-resources-protected-by-backup-plan
    ## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/dynamodb-resources-protected-by-backup-plan.html"

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    DYNAMODB_TABLE_ENCRYPTED_KMS
#
# Description:
#   All DynamoDB Tables must have SEE enabled
#
# Reports on:
#    AWS::DynamoDB::Table
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no DynamoDB Tables present
# b) SKIP: when metadata has rule suppression for DYNAMODB_TABLE_ENCRYPTED_KMS
# c) FAIL: when any DynamoDB Table does not have SSE enabled
# d) PASS: when all DynamoDB Tables have SSE enabled

#
# Select all DynamoDB Table resources from incoming template (payload)
#
let dynamodb_table_must_be_encrypted = Resources.*[ Type == 'AWS::DynamoDB::Table' 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DYNAMODB_TABLE_MUST_BE_ENCRYPTED"
]

rule DYNAMODB_TABLE_MUST_BE_ENCRYPTED when %dynamodb_table_must_be_encrypted !empty {
    %dynamodb_table_must_be_encrypted.Properties.SSESpecification EXISTS
    %dynamodb_table_must_be_encrypted.Properties.SSESpecification.SSEEnabled == true
      <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
        Violation: Amazon DynamoDB tables are configured with SSE 
        Fix: In SSESpecification, set SSEEnabled to true
      >>
}
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    DYNAMODB_TABLE_ENCRYPTED_KMS
#
# Description:
#   Checks if Amazon DynamoDB table is encrypted with AWS Key Management Service (KMS).
#
# Reports on:
#    AWS::DynamoDB::Table
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no DynamoDB Tables present
# b) SKIP: when metadata has rule suppression for DYNAMODB_TABLE_ENCRYPTED_KMS
# c) FAIL: when all DynamoDB Tables are not are encrypted with KMS
# d) PASS: when all DynamoDB Tables are encrypted with KMS

let dynamodb_table_encrypted_kms = Resources.*[ Type == "AWS::DynamoDB::Table"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DYNAMODB_TABLE_ENCRYPTED_KMS"
]

let DYNAMODB_TABLE_ENCRYPTED_KMS_ALLOWED_ALGORITHMS = [ "KMS" ]

rule DYNAMODB_TABLE_ENCRYPTED_KMS when %dynamodb_table_encrypted_kms !empty {
  %dynamodb_table_encrypted_kms.Properties.SSESpecification exists
  %dynamodb_table_encrypted_kms.Properties.SSESpecification.SSEEnabled == true
  %dynamodb_table_encrypted_kms.Properties.SSESpecification.KMSMasterKeyId exists
  %dynamodb_table_encrypted_kms.Properties.SSESpecification.SSEType in %DYNAMODB_TABLE_ENCRYPTED_KMS_ALLOWED_ALGORITHMS
      <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
        Violation: Amazon DynamoDB tables are configured with SSE and a KMS key
        Fix: In SSESpecification, set SSEEnabled to true and set KMSMasterKeyId to the ID of a KMS key
      >>
}

## Config Rule Name : dynamodb-in-backup-plan
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/dynamodb-in-backup-plan.html"

## Config Rule Name : dynamodb-throughput-limit-check
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/dynamodb-throughput-limit-check.html"

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#  DYNAMODB_PITR_ENABLED
#
# Description:
#  All DynamoDB Tables must have Point-In-Time-Recovery enabled.
#
# Reports on:
#  AWS::DynamoDB::Table
#
# Evaluates:
#  AWS CloudFormation
#
# Rule Parameters:
#  NA
#
# Scenarios:
# a) SKIP: when there are no DynamoDB Tables present
# b) SKIP: when metadata has rule suppression for DYNAMODB_PITR_ENABLED
# c) FAIL: when any DynamoDB Table is missing a PITR configuration
# d) FAIL: when any DynamoDB Table has PointInTimeRecoveryEnabled set to false
# d) PASS: when all DynamoDB Tables have PITR enabled

#
# Select all DynamoDB Table resources from incoming template (payload)
#
let dynamodb_pitr_enabled = Resources.*[ Type == "AWS::DynamoDB::Table" 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DYNAMODB_PITR_ENABLED"
]

rule DYNAMODB_PITR_ENABLED when %dynamodb_pitr_enabled !empty {
    %dynamodb_pitr_enabled.Properties.PointInTimeRecoverySpecification.PointInTimeRecoveryEnabled == true
    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
      Violation: All DynamoDB Tables must have Point-In-Time-Recovery enabled.
      Fix: Set the dynamodb table property PointInTimeRecoverySpecification.PointInTimeRecoveryEnabled to true.
    >>
}

## Config Rule Name : dynamodb-autoscaling-enabled
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/dynamodb-autoscaling-enabled.html"

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    SECRETSMANAGER_ROTATION_ENABLED_CHECK
#
# Description:
#   Checks if AWS Secrets Manager secret has rotation enabled.
#
# Reports on:
#    AWS::SecretsManager::Secret
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no Secrets Manager Secret resources
# b) PASS: when all Secrets Manager Secrets have an associated RotationPolicy
# c) FAIL: when any Secrets Manager Secrets is missing an associated RotationPolicy
# d) SKIP: when metada has rule suppression for SECRETSMANAGER_ROTATION_ENABLED_CHECK

let aws_secretsmanager_secret_rotate = Resources.*[ Type == "AWS::SecretsManager::Secret"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECRETSMANAGER_ROTATION_ENABLED_CHECK"
]

let aws_secretsmanager_rotation_schedule_rotate = Resources.*[ Type == "AWS::SecretsManager::RotationSchedule" ]

rule SECRETSMANAGER_ROTATION_ENABLED_CHECK when %aws_secretsmanager_secret_rotate !empty {
	%aws_secretsmanager_rotation_schedule_rotate !empty
	let secret_names = %aws_secretsmanager_rotation_schedule_rotate.Properties.SecretId.Ref
	let referenced_secrets = Resources[keys in %secret_names]
	%aws_secretsmanager_secret_rotate in %referenced_secrets
	<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
		Violation: Secret Manager Secret should be assocaited with a rotation schedule
		Fix: Reference the Secret Manager Secret resource ID in a AWS::SecretsManager::RotationSchedule resource
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    SECRETSMANAGER_USING_CMK
#
# Description:
#   Checks if all secrets in AWS Secrets Manager are encrypted using a customer managed key that was created in AWS Key Management Service (AWS KMS).
#
# Reports on:
#    AWS::SecretsManager::Secret
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no Secrets Manager Secret resources
# b) PASS: when all Secrets Manager Secrets have an associated customer managed CMK
# c) FAIL: when any Secrets Manager Secrets is missing an associated customer managed CMK
# d) SKIP: when metada has rule suppression for SECRETSMANAGER_USING_CMK

#
# Select all AWS::SageMaker::EndpointConfig resources from incoming template (payload)
#
let aws_secretsmanager_secret_cmk = Resources.*[ Type == "AWS::SecretsManager::Secret"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECRETSMANAGER_USING_CMK"
]



rule SECRETSMANAGER_USING_CMK when %aws_secretsmanager_secret_cmk !empty {
  %aws_secretsmanager_secret_cmk.Properties.KmsKeyId exists
  %aws_secretsmanager_secret_cmk.Properties.KmsKeyId not in ["alias/aws/secretsmanager"]
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: AWS Secrets Manager secrets are encrypted using an AWS KMS customer managed key
    Fix: Set the KmsKeyId property
  >>
}

## Config Rule Name : elb-acm-certificate-required
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/elb-acm-certificate-required.html"
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   ELB_ACM_CERTIFICATE_REQUIRED
#
# Description:
#   This rule checks whether the Classic Load Balancer uses HTTPS/SSL certificates provided by AWS Certificate Manager (ACM).
#   The rule will FAIL if the Classic Load Balancer configured with HTTPS/SSL listener does not use a certificate provided by ACM.
#
# Reports on:
#   AWS::ElasticLoadBalancing::LoadBalancer
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing Resources
# b) SKIP: when metadata has rule suppression for ELB_ACM_CERTIFICATE_REQUIRED
# c) SKIP: when there are no HTTPS or SSL 'Listeners'
# d) FAIL: when 'SSLCertificateId' does not matches an ACM certificate ARN for all HTTPS and SSL 'Listeners'
# e) PASS: when 'SSLCertificateId' matches an ACM certificate ARN for all HTTPS and SSL 'Listeners'

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elb_acm_certificate_required_resources = Resources.*[ Type == 'AWS::ElasticLoadBalancing::LoadBalancer'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELB_ACM_CERTIFICATE_REQUIRED"
]

rule ELB_ACM_CERTIFICATE_REQUIRED when %elb_acm_certificate_required_resources !empty {
    let doc = this
    %elb_acm_certificate_required_resources.Properties {
        Listeners[
            # Scenario c)
            Protocol in ['HTTPS', 'SSL']
        ] {
            # Scenarios d) and e)
            SSLCertificateId exists
            SSLCertificateId == /arn:aws[a-z0-9\-]*:acm:[a-z0-9\-]+:\d{12}:certificate\/[\w\-]{1,64}/ or 
            SSLCertificateId {
                Ref {
                    let resource_logical_name = this
                    let referenced_resource = %doc.Resources[ keys == %resource_logical_name ]
                    %referenced_resource not empty
                    %referenced_resource {
                        Type == "AWS::CertificateManager::Certificate"
                        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                            Violation: Classic Load Balancer Listeners need to use HTTPS/SSL certificates provided by AWS Certificate Manager (ACM).
                            Fix: Set the Classic Load Balancer Listeners.*.SSLCertificateId property to the ARN of an ACM Certificate.
                        >>    
                    }
                }
            }
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   ELB_PREDEFINED_SECURITY_POLICY_SSL_CHECK
#
# Description:
#   This rule checks whether Classic Load Balancers HTTPS/SSL listeners use the predefined security policy 'ELBSecurityPolicy-TLS-1-2-2017-01'.
#
# Reports on:
#   AWS::ElasticLoadBalancing::LoadBalancer
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing Resources
# b) SKIP: when metadata has rule suppression for ELB_PREDEFINED_SECURITY_POLICY_SSL_CHECK
# c) SKIP: when there are no HTTPS or SSL 'Listeners' configured
# d) FAIL: when 'Policies' does not contain a policy with 'PolicyType' equal to 'SSLNegotiationPolicyType' and 'Reference-Security-Policy' with a value of
#          'ELBSecurityPolicy-TLS-1-2-2017-01'
# e) FAIL: when a 'HTTPS' or 'SSL' Listener on the load balancer resource does not reference a secure policy
# f) PASS: when all 'HTTPS' and 'SSL' Listeners on the load balancer resource reference a secure policy

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elb_predefined_security_policy_ssl_check = Resources.*[ Type == 'AWS::ElasticLoadBalancing::LoadBalancer'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELB_PREDEFINED_SECURITY_POLICY_SSL_CHECK"
]

rule ELB_PREDEFINED_SECURITY_POLICY_SSL_CHECK when %elb_predefined_security_policy_ssl_check !empty {
    %elb_predefined_security_policy_ssl_check.Properties {
        let elb = this

        Listeners[ Protocol in ["HTTPS", "SSL"] ] {
            %elb.Policies exists
            %elb.Policies is_list
            %elb.Policies not empty

            let secure_policies = %elb.Policies[
                PolicyType == "SSLNegotiationPolicyType"
                some Attributes[*] {
                    Name == "Reference-Security-Policy"
                    Value in [ "ELBSecurityPolicy-TLS-1-2-2017-01" ]
                }
            ].PolicyName

            %secure_policies not empty

            PolicyNames exists
            PolicyNames is_list
            PolicyNames not empty
            some PolicyNames.* in %secure_policies
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: Classic Load Balancers HTTPS/SSL listeners use the predefined security policy 'ELBSecurityPolicy-TLS-1-2-2017-01'
                    Fix: Configure Classic Load Balancer HTTPS/SSL listeners to use the predefined security policy 'ELBSecurityPolicy-TLS-1-2-2017-01'
                >>
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   ELB_TLS_HTTPS_LISTENERS_ONLY
#
# Description:
#   This rule checks whether Classic Load Balancer listeners are configured with HTTPS or SSL protocol for front-end (client to load balancer).
#
# Reports on:
#   AWS::ElasticLoadBalancing::LoadBalancer
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing Resources
# b) SKIP: when metadata has rule suppression for ELB_TLS_HTTPS_LISTENERS_ONLY
# c) FAIL: when 'Protocol' on 'Listeners' is not set to 'HTTPS' or 'SSL'
# d) PASS: when 'Protocol' on all 'Listeners' is set to 'HTTPS' or 'SSL'

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elb_tls_https_listeners_only_resources = Resources.*[ Type == 'AWS::ElasticLoadBalancing::LoadBalancer'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELB_TLS_HTTPS_LISTENERS_ONLY"
]

rule ELB_TLS_HTTPS_LISTENERS_ONLY when %elb_tls_https_listeners_only_resources !empty {
    %elb_tls_https_listeners_only_resources.Properties {
        Listeners.* {
           # Scenarios c) and d)
           Protocol in ['HTTPS', 'SSL']
            <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                Violation: Classic Load Balancer listeners must be configured with HTTPS or SSL protocol for front-end (client to load balancer).
                Fix: Set a Classic Load Balancer Listeners.*.Protocol to 'HTTPS' or 'SSL'.
            >>
        }
    }
}
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   ELB_LOGGING_ENABLED
#
# Description:
#   This rule checks whether Classic Load Balancers have logging enabled.
#
# Reports on:
#   AWS::ElasticLoadBalancing::LoadBalancer
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing Resources
# b) SKIP: when metadata has rule suppression for ELB_LOGGING_ENABLED
# c) FAIL: when 'AccessLoggingPolicy' has not been specified
# d) FAIL: when 'AccessLoggingPolicy' has been specified and 'Enabled' in 'AccessLoggingPolicy' has been set to false
# e) PASS: when 'AccessLoggingPolicy' has been specified and 'Enabled' in 'AccessLoggingPolicy' has been set to true

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elb_logging_enabled_resources = Resources.*[ Type == 'AWS::ElasticLoadBalancing::LoadBalancer'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELB_LOGGING_ENABLED"
]

rule ELB_LOGGING_ENABLED when %elb_logging_enabled_resources !empty {
    %elb_logging_enabled_resources.Properties {
        AccessLoggingPolicy exists
        AccessLoggingPolicy {
            Enabled == true
            <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                Violation: This rule checks whether Classic Load Balancers have logging enabled.
                Fix: Set the Classic Load Balancer 'AccessLoggingPolicy.Enabled' property to true and 'S3BucketName' to an S3 bucket you own that has been configured to receive ELB logs.
            >>
        }
    }
}


#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   ELB_CROSS_ZONE_LOAD_BALANCING_ENABLED
#
# Description:
#   This rule will check to see if cross-zone load balancing is enabled for the Classic Load Balancer.
#
# Reports on:
#   AWS::ElasticLoadBalancing::LoadBalancer
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing Resources
# b) SKIP: when metadata has rule suppression for ELB_CROSS_ZONE_LOAD_BALANCING_ENABLED
# c) FAIL: when 'CrossZone' has not been specified
# d) FAIL: when 'CrossZone' has been specified and set to false
# e) PASS: when 'CrossZone' has been specified and set to true

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elb_cross_zone_load_balancing_resources = Resources.*[ Type == 'AWS::ElasticLoadBalancing::LoadBalancer'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELB_CROSS_ZONE_LOAD_BALANCING_ENABLED"
]

rule ELB_CROSS_ZONE_LOAD_BALANCING_ENABLED when %elb_cross_zone_load_balancing_resources !empty {
    %elb_cross_zone_load_balancing_resources.Properties {
        CrossZone exists
        CrossZone == true
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
            Violation: This rule will check to see if cross-zone load balancing is enabled for the Classic Load Balancer.
            Fix: Set the Classic Load Balancer CrossZone property to the true.
        >>
    }
}

    ## Config Rule Name : wafv2-logging-enabled
    ## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/wafv2-logging-enabled.html"

## Config Rule Name : elastic-beanstalk-managed-updates-enabled
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/elastic-beanstalk-managed-updates-enabled.html"

## Config Rule Name : beanstalk-enhanced-health-reporting-enabled
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/beanstalk-enhanced-health-reporting-enabled.html"

## Config Rule Name : emr-master-no-public-ip
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/emr-master-no-public-ip.html"

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    EMR_KERBEROS_ENABLED
#
# Description:
#   Checks if Kerberos is set for EMR cluster.
#
# Reports on:
#    AWS::EMR::Cluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when EMR cluster resource not present
# b) SKIP: when metada has rule suppression for EMR_KERBEROS_ENABLED
# c) FAIL: when all EMR cluster resources KerberosAttributes property does not exist
# d) PASS: when all EMR cluster resources KerberosAttributes property is set

#
# Select all EMR Cluster resources from incoming template (payload)
#

let emr_kerberos_enabled = Resources.*[ Type == "AWS::EMR::Cluster"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EMR_KERBEROS_ENABLED"
]

rule EMR_KERBEROS_ENABLED when %emr_kerberos_enabled !empty {
	%emr_kerberos_enabled.Properties.KerberosAttributes exists
	<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
		Violation: EMR Clusters have Kerberos configured
		Fix: Set the KerberosAttributes property
	>>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_INSTANCE_LOGGING_ENABLED
#
# Description:
#    Checks if log types exported to Amazon CloudWatch for an Amazon Relational
#    Database Service (Amazon RDS) instance are enabled.
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have EnableCloudwatchLogsExports set to true
# c) FAIL: when all RDS instances have EnableCloudwatchLogsExports set to false
# d) FAIL: when there are RDS instances with EnableCloudwatchLogsExports property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_INSTANCE_LOGGING_ENABLED

#
# Select all RDS instance resources from incoming template (payload)
#

let aws_rds_instances_logging_enabled = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_INSTANCE_LOGGING_ENABLED"
]


rule RDS_INSTANCE_LOGGING_ENABLED when %aws_rds_instances_logging_enabled !empty {
  %aws_rds_instances_logging_enabled.Properties.EnableCloudwatchLogsExports EXISTS
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: Enable CloudWatch Logs Exports for monitoring and logging.
    Fix: Provide EnableCloudWatchLogsExports object to start exporting cloudwatch logs.
  >>
}


#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_INSTANCE_PUBLIC_ACCESS_CHECK
#
# Description:
#    Checks if an RDS instances has Publicly Accessible not set.
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have PubliclyAccessible set to true
# c) FAIL: when all RDS instances have PubliclyAccessible set to false
# d) FAIL: when there are RDS instances with PubliclyAccessible property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_INSTANCE_PUBLIC_ACCESS_CHECK

#
# Select all RDS instance resources from incoming template (payload)
#
let aws_rds_instances_not_public = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_INSTANCE_PUBLIC_ACCESS_CHECK"
]

rule RDS_INSTANCE_PUBLIC_ACCESS_CHECK when %aws_rds_instances_not_public !empty {
  # ALL RDS instances must have PubliclyAccessible set to false
  %aws_rds_instances_not_public.Properties.PubliclyAccessible == false
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: All RDS instances must not be publicly accessible.
    Fix: Set the PubliclyAccessible to false.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    DB_INSTANCE_BACKUP_ENABLED
#
# Description:
#    Checks if RDS DB instances have backups enabled.
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have BackupRetentionPeriod set to a positive number
# c) FAIL: when all RDS instances have BackupRetentionPeriod set to 0
# d) FAIL: when there are RDS instances with BackupRetentionPeriod property is not present
# e) SKIP: when metadata includes the suppression for rule DB_INSTANCE_BACKUP_ENABLED

#
# Select all RDS instance resources from incoming template (payload)
#

let aws_rds_instances_db_instance_backup_enabled = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DB_INSTANCE_BACKUP_ENABLED"
]


rule DB_INSTANCE_BACKUP_ENABLED when %aws_rds_instances_db_instance_backup_enabled !empty {
  %aws_rds_instances_db_instance_backup_enabled.Properties.BackupRetentionPeriod EXISTS
  %aws_rds_instances_db_instance_backup_enabled.Properties.BackupRetentionPeriod >= 1
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: All RDS instances must have automated backup enabled.
    Fix: Set the BackupRetentionPeriod to values of 1 to 35 to enable backups.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_AUTOMATIC_MINOR_VERSION_UPGRADE_ENABLED
#
# Description:
#    Checks whether storage encryption is enabled for your RDS DB instances
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have AutoMinorVersionUpgrade set to true
# c) FAIL: when all RDS instances have AutoMinorVersionUpgrade set to false
# d) FAIL: when there are RDS instances with AutoMinorVersionUpgrade property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_AUTOMATIC_MINOR_VERSION_UPGRADE_ENABLED

#
# Select all RDS instance resources from incoming template (payload)
#

let aws_rds_instances_minor_version_upgrade_enabled = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_AUTOMATIC_MINOR_VERSION_UPGRADE_ENABLED"
]


rule RDS_AUTOMATIC_MINOR_VERSION_UPGRADE_ENABLED when %aws_rds_instances_minor_version_upgrade_enabled !empty {
  %aws_rds_instances_minor_version_upgrade_enabled.Properties.AutoMinorVersionUpgrade EXISTS
  %aws_rds_instances_minor_version_upgrade_enabled.Properties.AutoMinorVersionUpgrade == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: All RDS instances must have automatic minor version upgrade enabled.
    Fix: Set the AutoMinorVersionUpgrade parameter to true.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    AURORA_MYSQL_BACKTRACKING_ENABLED
#
# Description:
#    Checks if an Amazon Aurora MySQL cluster has backtracking enabled.
#
# Reports on:
#    AWS::RDS::DBCluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all aurora-mysql RDS instances have BacktrackWindow set to greater than 0
# c) FAIL: when all aurora-mysql RDS instances have BacktrackWindow set to 0
# d) FAIL: when there are aurora-mysql RDS instances with BacktrackWindow property is not present
# e) SKIP: hen metadata includes the suppression for rule AURORA_MYSQL_BACKTRACKING_ENABLED

#
# Select all RDS Clusters resources from incoming template (payload)
#

let aws_rds_clusters_aurora_mysql_backtracking_enabled = Resources.*[ Type == 'AWS::RDS::DBCluster'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "AURORA_MYSQL_BACKTRACKING_ENABLED"
]

rule AURORA_MYSQL_BACKTRACKING_ENABLED when %aws_rds_clusters_aurora_mysql_backtracking_enabled !empty {
    # only eval aurora-mysql engine types
    when %aws_rds_clusters_aurora_mysql_backtracking_enabled.Properties.Engine == 'aurora-mysql' {
      %aws_rds_clusters_aurora_mysql_backtracking_enabled.Properties.BacktrackWindow EXISTS
      %aws_rds_clusters_aurora_mysql_backtracking_enabled.Properties.BacktrackWindow >= 1
      <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
        Violation: All MySQL Aurora RDS DB Clusters have backtrack enabled.
        Fix: Set BacktrackWindow parameter value to greater than 0.
      >>
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_MULTI_AZ_SUPPORT
#
# Description:
#    In a Multi-AZ deployment, Amazon RDS automatically provisions and maintains a synchronous
#    standby replica in a different Availability Zone.
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have MultiAZ set to true
# c) FAIL: when all RDS instances have MultiAZ set to false
# d) FAIL: when there are RDS instances with MultiAZ property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_MULTI_AZ_SUPPORT

#
# Select all RDS instance resources from incoming template (payload)
#
let aws_rds_instances_multi_az_support = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_MULTI_AZ_SUPPORT"
]

rule RDS_MULTI_AZ_SUPPORT when %aws_rds_instances_multi_az_support !empty {
    %aws_rds_instances_multi_az_support.Properties.MultiAZ EXISTS
    %aws_rds_instances_multi_az_support.Properties.MultiAZ == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: All RDS instances must have MultiAZ support enabled.
    Fix: Set the MultiAZ parameter to true.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_SNAPSHOT_ENCRYPTED
#
# Description:
#    Checks whether Amazon Relational Database Service (Amazon RDS) DB snapshots are encrypted.
#
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have StorageEncrypted set to true
# c) FAIL: when all RDS instances have StorageEncrypted set to false
# d) FAIL: when there are RDS instances with StorageEncrypted property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_SNAPSHOT_ENCRYPTED

#
# Select all RDS instance resources from incoming template (payload)
#
let aws_rds_instances_snapshot_encrypted = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_SNAPSHOT_ENCRYPTED"
]


rule RDS_SNAPSHOT_ENCRYPTED when %aws_rds_instances_snapshot_encrypted !empty {
  %aws_rds_instances_snapshot_encrypted.Properties.StorageEncrypted EXISTS
  %aws_rds_instances_snapshot_encrypted.Properties.StorageEncrypted == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: All RDS instances must have snapshots encrypted.
    Fix: Set the StorageEncrypted parameter to true so by default all snapshots are encrypted.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_ENHANCED_MONITORING_ENABLED
#
# Description:
#    Checks whether enhanced monitoring is enabled for Amazon Relational Database Service (Amazon RDS) instances.
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have MonitoringInterval set to a value of 1, 5, 10, 15, 30, or 60
# c) FAIL: when all RDS instances have MonitoringInterval set to 0
# d) FAIL: when there are RDS instances with MonitoringInterval property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_ENHANCED_MONITORING_ENABLED


#
# Select all RDS instance resources from incoming template (payload)
#

let aws_rds_instances_enhanced_monitoring_enabled = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_ENHANCED_MONITORING_ENABLED"
]


rule RDS_ENHANCED_MONITORING_ENABLED when %aws_rds_instances_enhanced_monitoring_enabled !empty {
  %aws_rds_instances_enhanced_monitoring_enabled.Properties.MonitoringInterval EXISTS
  %aws_rds_instances_enhanced_monitoring_enabled.Properties.MonitoringInterval IN [1, 5, 10, 15, 30, 60]
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: RDS Instance enhanced monitoring required.
    Fix: Specify a value of 1, 5, 10, 15, 30, or 60 for the parameter on the property MonitoringInterval.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_INSTANCE_DELETION_PROTECTION_ENABLED
#
# Description:
#    Checks if an Amazon Relational Database Service (Amazon RDS) instance has deletion protection enabled.
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have DeletionProtection set to true
# c) FAIL: when all RDS instances have DeletionProtection set to false
# d) FAIL: when there are RDS instances with DeletionProtection property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_INSTANCE_DELETION_PROTECTION_ENABLED

#
# Select all RDS instance resources from incoming template (payload)
#
let aws_rds_instances_deletion_protection_enabled = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_INSTANCE_DELETION_PROTECTION_ENABLED"
]

rule RDS_INSTANCE_DELETION_PROTECTION_ENABLED when %aws_rds_instances_deletion_protection_enabled !empty {
  %aws_rds_instances_deletion_protection_enabled.Properties.DeletionProtection EXISTS
  %aws_rds_instances_deletion_protection_enabled.Properties.DeletionProtection == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: All RDS instances must deletion protection enabled.
    Fix: Set the parameter for DeletionProtection to true.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_STORAGE_ENCRYPTED
#
# Description:
#    Checks whether storage encryption is enabled for your RDS DB instances.
#
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have StorageEncrypted set to true
# c) FAIL: when all RDS instances have StorageEncrypted set to false
# d) FAIL: when there are RDS instances with StorageEncrypted property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_STORAGE_ENCRYPTED

#
# Select all RDS instance resources from incoming template (payload)
#
let aws_rds_instances_storage_encrypted = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_STORAGE_ENCRYPTED"
]


rule RDS_STORAGE_ENCRYPTED when %aws_rds_instances_storage_encrypted !empty {
  %aws_rds_instances_storage_encrypted.Properties.StorageEncrypted EXISTS
  %aws_rds_instances_storage_encrypted.Properties.StorageEncrypted == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: All RDS instances must have encrypted storage.
    Fix: Set the StorageEncrypted parameter to true.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUD_TRAIL_LOG_FILE_VALIDATION_ENABLED
#
# Description:
#   Checks whether AWS CloudTrail creates a signed digest file with logs.
#
# Reports on:
#    AWS::CloudTrail::Trail
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudTrail Trails present
# b) PASS: when all CloudTrail Trails have EnableLogFileValidation parameter set true
# c) FAIL: when there are CloudTrail Trails with the EnableLogFileValidation parameter is set to false
# d) FAIL: when there are CloudTrail Trails with EnableLogFileValidation property not present
# e) SKIP: when metada has rule suppression for CLOUD_TRAIL_LOG_FILE_VALIDATION_ENABLED


#
# Select all CloudTrail Trail resources from incoming template (payload)
#
let cloudtrail_trails_log_validation = Resources.*[ Type == 'AWS::CloudTrail::Trail'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUD_TRAIL_LOG_FILE_VALIDATION_ENABLED"
]

rule CLOUD_TRAIL_LOG_FILE_VALIDATION_ENABLED when %cloudtrail_trails_log_validation !empty {
  %cloudtrail_trails_log_validation.Properties.EnableLogFileValidation EXISTS
  %cloudtrail_trails_log_validation.Properties.EnableLogFileValidation == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudTrail Trail should have Log File Validation enabled.
    Fix: Set the EnableLogFileValidation parameter to true.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUD_TRAIL_ENABLED
#
# Description:
#   Checks if AWS CloudTrail is enabled.
#
# Reports on:
#    AWS::CloudTrail::Trail
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudTrail Trails present
# b) PASS: when all CloudTrail Trails have IsLogging parameter set true
# c) FAIL: when there are CloudTrail Trails with the IsLogging parameter is set to false
# d) FAIL: when there are CloudTrail Trails with IsLogging property not present
# e) SKIP: when metada has rule suppression for CLOUD_TRAIL_ENABLED

#
# Select all CloudTrail Trail resources from incoming template (payload)
#
let cloudtrail_trails_enabled = Resources.*[ Type == 'AWS::CloudTrail::Trail'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUD_TRAIL_ENABLED"
]

rule CLOUD_TRAIL_ENABLED when %cloudtrail_trails_enabled !empty {
  %cloudtrail_trails_enabled.Properties.IsLogging EXISTS
  %cloudtrail_trails_enabled.Properties.IsLogging == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudTrail Trail should be enabled.
    Fix: Set the IsLogging parameter to true.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDTRAIL_S3_DATAEVENTS_ENABLED
#
# Description:
#   Checks whether at least one AWS CloudTrail trail is logging Amazon S3 data events for all S3 buckets.
#
# Reports on:
#    AWS::CloudTrail::Trail
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudTrail Trails present
# b) PASS: when all CloudTrail Trails have EventSelectors parameter set
# c) FAIL: when there are CloudTrail Trails with EventSelectors property not present
# d) SKIP: when metada has rule suppression for CLOUDTRAIL_S3_DATAEVENTS_ENABLED

#
# Select all CloudTrail Trail resources from incoming template (payload)
#
let cloudtrail_trails_dataevents = Resources.*[ Type == 'AWS::CloudTrail::Trail'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDTRAIL_S3_DATAEVENTS_ENABLED"
]

rule CLOUDTRAIL_S3_DATAEVENTS_ENABLED when %cloudtrail_trails_dataevents !empty {
  %cloudtrail_trails_dataevents.Properties.EventSelectors EXISTS
  some %cloudtrail_trails_dataevents.Properties.EventSelectors.* == {DataResources:[{Type:'AWS::S3::Object',Values:['arn:aws:s3:::']}],IncludeManagementEvents:true,ReadWriteType:'All'}
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudTrail Trail should have data events being logged.
    Fix: Set the EventSelectors parameter to enable encryption. The value can be an alias name prefixed by "alias/", a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUD_TRAIL_CLOUD_WATCH_LOGS_ENABLED
#
# Description:
#   Checks whether AWS CloudTrail trails are configured to send logs to Amazon CloudWatch logs.
#   The trail is non-compliant if the CloudWatchLogsLogGroupArn property of the trail is empty.
#
# Reports on:
#    AWS::CloudTrail::Trail
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudTrail Trails present
# b) PASS: when all CloudTrail Trails have CloudWatchLogsLogGroupArn parameter set
# c) FAIL: when there are CloudTrail Trails with CloudWatchLogsLogGroupArn property not present
# d) SKIP: when metada has rule suppression for CLOUD_TRAIL_CLOUD_WATCH_LOGS_ENABLED

#
# Select all CloudTrail Trail resources from incoming template (payload)
#
let cloudtrail_trails_cw_logs_enabled = Resources.*[ Type == 'AWS::CloudTrail::Trail'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUD_TRAIL_CLOUD_WATCH_LOGS_ENABLED"
]

rule CLOUD_TRAIL_CLOUD_WATCH_LOGS_ENABLED when %cloudtrail_trails_cw_logs_enabled !empty {
  %cloudtrail_trails_cw_logs_enabled.Properties.CloudWatchLogsLogGroupArn exists
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudTrail Trail should have logs exported to cloudwatch logs.
    Fix: Set the CloudWatchLogsLogGroupArn parameter to enable exporting to CloudWatch Logs.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    MULTI_REGION_CLOUD_TRAIL_ENABLED
#
# Description:
#   Checks if there is at least one multi-region AWS CloudTrail.
#
# Reports on:
#    AWS::CloudTrail::Trail
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudTrail Trails present
# b) PASS: when all CloudTrail Trails have IsMultiRegionTrail parameter set true
# c) FAIL: when there are CloudTrail Trails with the IsMultiRegionTrail parameter is set to false
# d) FAIL: when there are CloudTrail Trails with IsMultiRegionTrail property not present
# e) SKIP: when metada has rule suppression for MULTI_REGION_CLOUD_TRAIL_ENABLED

#
# Select all CloudTrail Trail resources from incoming template (payload)
#
let cloudtrail_trails_multiregion = Resources.*[ Type == 'AWS::CloudTrail::Trail'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "MULTI_REGION_CLOUD_TRAIL_ENABLED"
]

rule MULTI_REGION_CLOUD_TRAIL_ENABLED when %cloudtrail_trails_multiregion !empty {
  %cloudtrail_trails_multiregion.Properties.IsMultiRegionTrail EXISTS
  %cloudtrail_trails_multiregion.Properties.IsMultiRegionTrail == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudTrail Trail should be set to log multiple regions.
    Fix: Set the IsMultiRegionTrail parameter to true.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUD_TRAIL_ENCRYPTION_ENABLED
#
# Description:
#   Checks if AWS CloudTrail is configured to use the server side encryption (SSE)
#   AWS Key Management Service KMS key encryption.
#
# Reports on:
#    AWS::CloudTrail::Trail
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudTrail Trails present
# b) PASS: when all CloudTrail Trails have KMSKeyId parameter set
# c) FAIL: when there are CloudTrail Trails with KMSKeyId property not present
# d) SKIP: when metada has rule suppression for CLOUD_TRAIL_ENCRYPTION_ENABLED

#
# Select all CloudTrail Trail resources from incoming template (payload)
#
let cloudtrail_trails_encryption = Resources.*[ Type == 'AWS::CloudTrail::Trail'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUD_TRAIL_ENCRYPTION_ENABLED"
]

rule CLOUD_TRAIL_ENCRYPTION_ENABLED when %cloudtrail_trails_encryption !empty {
  %cloudtrail_trails_encryption.Properties.KMSKeyId EXISTS
  %cloudtrail_trails_encryption.Properties.KMSKeyId is_string
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: CloudTrail Trail should be used to encrypt logs delivered by CloudTrail.
    Fix: Set the KMSKeyId parameter to enable encryption. The value can be an alias name prefixed by "alias/", a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_PRIMARY_NODE_FAULT_TOLERANCE
#
# Description:
#   Elasticsearch domains are configured with at least three dedicated primary nodes
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no ElasticSearch Domain Resources 
# b) SKIP: when metadata has rule suppression for ELASTICSEARCH_PRIMARY_NODE_FAULT_TOLERANCE
# c) FAIL: when ElasticSearch Domain Resources are missing ElasticsearchClusterConfig.DedicatedMasterEnabled
# d) FAIL: when ElasticSearch Domain Resources have ElasticsearchClusterConfig.DedicatedMasterEnabled set to a value other than true 
# e) FAIL: when ElasticSearch Domain Resources have ElasticsearchClusterConfig.DedicatedMasterCount set to an integer value less than three (<3) 
# f) PASS: when ElasticSearch Domain Resources have ElasticsearchClusterConfig.DedicatedMasterEnabled set to true and 
#          ElasticsearchClusterConfig.DedicatedMasterCount has not been provided
# g) PASS: when ElasticSearch Domain Resources have ElasticsearchClusterConfig.DedicatedMasterEnabled set to true and 
#          ElasticsearchClusterConfig.DedicatedMasterCount set to an integer value greater than or equal to three (>= 3) 

#
# Select all ElasticSearch domains from incoming template
#
let elasticsearch_primary_node_fault_tolerance = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_PRIMARY_NODE_FAULT_TOLERANCE"
]

rule ELASTICSEARCH_PRIMARY_NODE_FAULT_TOLERANCE when %elasticsearch_primary_node_fault_tolerance !empty {
    %elasticsearch_primary_node_fault_tolerance.Properties { 
        ElasticsearchClusterConfig exists
        ElasticsearchClusterConfig is_struct

        ElasticsearchClusterConfig {
            DedicatedMasterEnabled exists
            DedicatedMasterEnabled == true
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: Elasticsearch domains are configured with at least three dedicated primary nodes
                    Fix: In ElasticsearchClusterConfig, set DedicatedMasterEnabled to true and DedicatedMasterCount to an integer value greater than 3.
                >>
            DedicatedMasterCount not exists or
            DedicatedMasterCount >= 3
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: Elasticsearch domains are configured with at least three dedicated primary nodes
                    Fix: In ElasticsearchClusterConfig, set DedicatedMasterEnabled to true and DedicatedMasterCount to an integer value greater than 3.
                >>
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   OPENSEARCH_IN_VPC_ONLY
#
# Description:
#   OpenSearchService domains must be in a VPC
#
# Reports on:
#   AWS::OpenSearchService::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there is no OpenSearchService domain present
# b) SKIP: when metadata has rule suppression for OPENSEARCH_IN_VPC_ONLY
# c) PASS: when OpenSearchService domain has VPCOptions or Endpoint properties
# d) FAIL: when OpenSearchService domain does not have VPCOptions or Endpoint properties

#
# Select all elasticsearch domains from incoming template
#
let opensearch_in_vpc_only = Resources.*[ Type == "AWS::OpenSearchService::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "OPENSEARCH_IN_VPC_ONLY"
]

rule OPENSEARCH_IN_VPC_ONLY when %opensearch_in_vpc_only !empty {
    %opensearch_in_vpc_only.Properties.VPCOptions exists
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
            Violation: OpenSearchService domains must be in a VPC.
            Fix: Provide VPCOptions object to enable opensearch to function in a VPC.
        >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   OPENSEARCH_APPLICATION_LOGGING_ENABLED
#
# Description:
#   OpenSearchService domains are are configured to send application logs to Amazon CloudWatch Logs
#
# Reports on:
#   AWS::OpenSearchService::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no OpenSearchService Domain Resources 
# b) SKIP: when metadata has rule suppression for OPENSEARCH_APPLICATION_LOGGING_ENABLED
# c) FAIL: when OpenSearchService Domain Resources are missing LogPublishingOptions.ES_APPLICATION_LOGS.Enabled or LogPublishingOptions.ES_APPLICATION_LOGS.CloudWatchLogsLogGroupArn
# d) FAIL: when OpenSearchService Domain Resources have LogPublishingOptions.ES_APPLICATION_LOGS.Enabled set to a value other than true 
# e) FAIL: when OpenSearchService Domain Resources have LogPublishingOptions.ES_APPLICATION_LOGS.CloudWatchLogsLogGroupArn set to a value other than a string or struct  
# f) PASS: when OpenSearchService Domain Resources have LogPublishingOptions.ES_APPLICATION_LOGS.Enabled set to true and 
#          LogPublishingOptions.ES_APPLICATION_LOGS.CloudWatchLogsLogGroupArn set to a string or struct value  

#
# Select all OpenSearchService domains from incoming template
#
let opensearch_application_logging_enabled = Resources.*[ Type == "AWS::OpenSearchService::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "OPENSEARCH_APPLICATION_LOGGING_ENABLED"
]

rule OPENSEARCH_APPLICATION_LOGGING_ENABLED when %opensearch_application_logging_enabled !empty {
    %opensearch_application_logging_enabled.Properties { 
        LogPublishingOptions exists
        LogPublishingOptions is_struct

        LogPublishingOptions {
            ES_APPLICATION_LOGS exists
            ES_APPLICATION_LOGS is_struct

            ES_APPLICATION_LOGS {
                Enabled exists
                Enabled == true
                    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                        Violation: OpenSearchService domains are are configured to send application logs to Amazon CloudWatch Logs
                        Fix: In LogPublishingOptions.ES_APPLICATION_LOGS, set Enabled to true and CloudWatchLogsLogGroupArn to the ARN of a Amazon CloudWatch Logs log group.
                    >>
                CloudWatchLogsLogGroupArn exists
                CloudWatchLogsLogGroupArn is_string or
                CloudWatchLogsLogGroupArn is_struct
                    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                        Violation: OpenSearchService domains are are configured to send application logs to Amazon CloudWatch Logs
                        Fix: In LogPublishingOptions.ES_APPLICATION_LOGS, set Enabled to true and CloudWatchLogsLogGroupArn to the ARN of a Amazon CloudWatch Logs log group.
                    >>
            }
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_DATA_NODE_FAULT_TOLERANCE
#
# Description:
#   Elasticsearch domains are configured with at least three data nodes and zone awareness enabled.
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no ElasticSearch Domain Resources 
# b) SKIP: when metadata has rule suppression for ELASTICSEARCH_DATA_NODE_FAULT_TOLERANCE
# c) FAIL: when ElasticSearch Domain Resources are missing ElasticsearchClusterConfig.ZoneAwarenessEnabled or ElasticsearchClusterConfig.InstanceCount
# d) FAIL: when ElasticSearch Domain Resources have ElasticsearchClusterConfig.ZoneAwarenessEnabled set to a value other than true 
# e) FAIL: when ElasticSearch Domain Resources have ElasticsearchClusterConfig.InstanceCount set to an integer value less than three (<3) 
# f) PASS: when ElasticSearch Domain Resources have ElasticsearchClusterConfig.ZoneAwarenessEnabled set to true and 
#          ElasticsearchClusterConfig.InstanceCount set to an integer value greater than or equal to three (>= 3) 

#
# Select all ElasticSearch domains from incoming template
#
let elasticsearch_data_node_fault_tolerance = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_DATA_NODE_FAULT_TOLERANCE"
]

rule ELASTICSEARCH_DATA_NODE_FAULT_TOLERANCE when %elasticsearch_data_node_fault_tolerance !empty {
    %elasticsearch_data_node_fault_tolerance.Properties { 
        ElasticsearchClusterConfig exists
        ElasticsearchClusterConfig is_struct

        ElasticsearchClusterConfig {
            ZoneAwarenessEnabled exists
            ZoneAwarenessEnabled == true
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: Elasticsearch domains are configured with at least three data nodes and zone awareness enabled
                    Fix: In ElasticsearchClusterConfig, set ZoneAwarenessEnabled to true and InstanceCount to an integer value greater than 3.
                >>
            InstanceCount exists
            InstanceCount >= 3
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: Elasticsearch domains are configured with at least three data nodes and zone awareness enabled
                    Fix: In ElasticsearchClusterConfig, set ZoneAwarenessEnabled to true and InstanceCount to an integer value greater than 3.
                >>
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_AUDIT_LOGGING_ENABLED
#
# Description:
#   Elasticsearch domains are are configured to send audit logs to Amazon CloudWatch Logs
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no ElasticSearch Domain Resources 
# b) SKIP: when metadata has rule suppression for ELASTICSEARCH_AUDIT_LOGGING_ENABLED
# c) FAIL: when ElasticSearch Domain Resources are missing LogPublishingOptions.AUDIT_LOGS.Enabled or LogPublishingOptions.AUDIT_LOGS.CloudWatchLogsLogGroupArn
# d) FAIL: when ElasticSearch Domain Resources have LogPublishingOptions.AUDIT_LOGS.Enabled set to a value other than true 
# e) FAIL: when ElasticSearch Domain Resources have LogPublishingOptions.AUDIT_LOGS.CloudWatchLogsLogGroupArn set to a value other than a string or struct  
# f) PASS: when ElasticSearch Domain Resources have LogPublishingOptions.AUDIT_LOGS.Enabled set to true and 
#          LogPublishingOptions.AUDIT_LOGS.CloudWatchLogsLogGroupArn set to a string or struct value  

#
# Select all ElasticSearch domains from incoming template
#
let elasticsearch_audit_logging_enabled = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_AUDIT_LOGGING_ENABLED"
]

rule ELASTICSEARCH_AUDIT_LOGGING_ENABLED when %elasticsearch_audit_logging_enabled !empty {
    %elasticsearch_audit_logging_enabled.Properties { 
        LogPublishingOptions exists
        LogPublishingOptions is_struct

        LogPublishingOptions {
            AUDIT_LOGS exists
            AUDIT_LOGS is_struct

            AUDIT_LOGS {
                Enabled exists
                Enabled == true
                    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                        Violation: Elasticsearch domains are are configured to send audit logs to Amazon CloudWatch Logs
                        Fix: In LogPublishingOptions.AUDIT_LOGS, set Enabled to true and CloudWatchLogsLogGroupArn to the ARN of a Amazon CloudWatch Logs log group.
                    >>
                CloudWatchLogsLogGroupArn exists
                CloudWatchLogsLogGroupArn is_string or
                CloudWatchLogsLogGroupArn is_struct
                    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                        Violation: Elasticsearch domains are are configured to send audit logs to Amazon CloudWatch Logs
                        Fix: In LogPublishingOptions.AUDIT_LOGS, set Enabled to true and CloudWatchLogsLogGroupArn to the ARN of a Amazon CloudWatch Logs log group.
                    >>
            }
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   OPENSEARCH_ENCRYPTED_AT_REST
#
# Description:
#   OpenSearchService domains must enforce server side encryption
#
# Reports on:
#   AWS::OpenSearchService::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there is no OpenSearchService domain present
# b) SKIP: when metada has rule suppression for OPENSEARCH_ENCRYPTED_AT_REST
# c) FAIL: when OpenSearchService domain has server side encryption property is missing
# d) FAIL: when OpenSearchService domain has server side encryption set to false
# e) PASS: when OpenSearchService domain has server side encryption set to true

#
# Select all elasticsearch domains from incoming template
#
let elasticsearch_domains_encrypted = Resources.*[ Type == "AWS::OpenSearchService::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "OPENSEARCH_ENCRYPTED_AT_REST"
]

rule OPENSEARCH_ENCRYPTED_AT_REST when %elasticsearch_domains_encrypted !empty {
    %elasticsearch_domains_encrypted.Properties.EncryptionAtRestOptions.Enabled == true
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
            Violation: OpenSearchService domains must enforce server side encryption.
            Fix: Set EncryptionAtRestOptions.Enabled to true.
        >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   OPENSEARCH_DATA_NODE_FAULT_TOLERANCE
#
# Description:
#   OpenSearchService domains are configured with at least three data nodes and zone awareness enabled.
#
# Reports on:
#   AWS::OpenSearchService::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no OpenSearchService Domain Resources 
# b) SKIP: when metadata has rule suppression for OPENSEARCH_DATA_NODE_FAULT_TOLERANCE
# c) FAIL: when OpenSearchService Domain Resources are missing ClusterConfig.ZoneAwarenessEnabled or ClusterConfig.InstanceCount
# d) FAIL: when OpenSearchService Domain Resources have ClusterConfig.ZoneAwarenessEnabled set to a value other than true 
# e) FAIL: when OpenSearchService Domain Resources have ClusterConfig.InstanceCount set to an integer value less than three (<3) 
# f) PASS: when OpenSearchService Domain Resources have ClusterConfig.ZoneAwarenessEnabled set to true and 
#          ClusterConfig.InstanceCount set to an integer value greater than or equal to three (>= 3) 

#
# Select all OpenSearchService domains from incoming template
#
let opensearch_data_node_fault_tolerance = Resources.*[ Type == "AWS::OpenSearchService::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "OPENSEARCH_DATA_NODE_FAULT_TOLERANCE"
]

rule OPENSEARCH_DATA_NODE_FAULT_TOLERANCE when %opensearch_data_node_fault_tolerance !empty {
    %opensearch_data_node_fault_tolerance.Properties { 
        ClusterConfig exists
        ClusterConfig is_struct

        ClusterConfig {
            ZoneAwarenessEnabled exists
            ZoneAwarenessEnabled == true
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: OpenSearchService domains are configured with at least three data nodes and zone awareness enabled
                    Fix: In ClusterConfig, set ZoneAwarenessEnabled to true and InstanceCount to an integer value greater than 3.
                >>
            InstanceCount exists
            InstanceCount >= 3
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: OpenSearchService domains are configured with at least three data nodes and zone awareness enabled
                    Fix: In ClusterConfig, set ZoneAwarenessEnabled to true and InstanceCount to an integer value greater than 3.
                >>
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_HTTPS_REQUIRED
#
# Description:
#   Elasticsearch domains are configured to require HTTPS with a minimum TLS version of TLSv1.2
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no Elasticsearch Domain Resources 
# b) SKIP: when metadata has rule suppression for ELASTICSEARCH_HTTPS_REQUIRED
# c) FAIL: when Elasticsearch Domain Resources are missing DomainEndpointOptions.EnforceHTTPS
# d) FAIL: when Elasticsearch Domain Resources are missing DomainEndpointOptions.TLSSecurityPolicy
# e) FAIL: when Elasticsearch Domain Resources have DomainEndpointOptions.EnforceHTTPS set to a value other than true 
# f) FAIL: when Elasticsearch Domain Resources have DomainEndpointOptions.TLSSecurityPolicy set to a value other than 'Policy-Min-TLS-1-2-2019-07'
# g) PASS: when Elasticsearch Domain Resources have DomainEndpointOptions.EnforceHTTPS set to true and 
#          DomainEndpointOptions.TLSSecurityPolicy set to 'Policy-Min-TLS-1-2-2019-07'

#
# Select all Elasticsearch domains from incoming template
#
let elasticsearch_https_required = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_HTTPS_REQUIRED"
]

rule ELASTICSEARCH_HTTPS_REQUIRED when %elasticsearch_https_required !empty {
    %elasticsearch_https_required.Properties { 
        DomainEndpointOptions exists
        DomainEndpointOptions is_struct

        DomainEndpointOptions {
            EnforceHTTPS exists
            EnforceHTTPS == true
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: Elasticsearch domains are configured to require HTTPS with a minimum TLS version of TLSv1.2
                    Fix: In DomainEndpointOptions, set EnforceHTTPS to true and TLSSecurityPolicy to 'Policy-Min-TLS-1-2-2019-07'
                >>
            TLSSecurityPolicy exists
            TLSSecurityPolicy in [ "Policy-Min-TLS-1-2-2019-07" ]
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: Elasticsearch domains are configured to require HTTPS with a minimum TLS version of TLSv1.2
                    Fix: In DomainEndpointOptions, set EnforceHTTPS to true and TLSSecurityPolicy to 'Policy-Min-TLS-1-2-2019-07'
                >>
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_IN_VPC_ONLY
#
# Description:
#   Elasticsearch domains must be in a VPC
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there is no elasticsearch domain present
# b) SKIP: when metada has rule suppression for ELASTICSEARCH_IN_VPC_ONLY
# c) PASS: when elasticsearch domain has VPCOptions or Endpoint properties
# d) FAIL: when elasticsearch domain does not have VPCOptions or Endpoint properties

#
# Select all elasticsearch domains from incoming template
#
let elasticsearch_domains_vpc_required = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_IN_VPC_ONLY"
]

rule ELASTICSEARCH_IN_VPC_ONLY when %elasticsearch_domains_vpc_required !empty {
    %elasticsearch_domains_vpc_required.Properties.VPCOptions EXISTS
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
            Violation: Elasticsearch domains must be in a VPC.
            Fix: Provide VPCOptions object to enable opensearch to function in a VPC.
        >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   OPENSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK
#
# Description:
#   OpenSearchService domains must enforce Node-to-Node Encryption
#
# Reports on:
#   AWS::OpenSearchService::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there is no elasticsearch domain present
# b) SKIP: when metada has rule suppression for OPENSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK
# c) FAIL: when OpenSearchService domain has Node-to-Node encryption property missing
# d) FAIL: when OpenSearchService domain has Node-to-Node encryption set to false
# e) PASS: when OpenSearchService domain has Node-to-Node encryption set to true

#
# Select all elasticsearch domains from incoming template
#
let opensearch_node_to_node_encryption_check = Resources.*[ Type == "AWS::OpenSearchService::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "OPENSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK"
]

rule OPENSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK when %opensearch_node_to_node_encryption_check !empty {
    %opensearch_node_to_node_encryption_check.Properties.NodeToNodeEncryptionOptions.Enabled == true
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
            Violation: OpenSearchService domains must enforce Node-to-Node Encryption.
            Fix: Set the NodeToNodeEncryptionOptions.Enabled parameter to true.
        >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_APPLICATION_LOGGING_ENABLED
#
# Description:
#   Elasticsearch domains are are configured to send application logs to Amazon CloudWatch Logs
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no ElasticSearch Domain Resources 
# b) SKIP: when metadata has rule suppression for ELASTICSEARCH_APPLICATION_LOGGING_ENABLED
# c) FAIL: when ElasticSearch Domain Resources are missing LogPublishingOptions.ES_APPLICATION_LOGS.Enabled or LogPublishingOptions.ES_APPLICATION_LOGS.CloudWatchLogsLogGroupArn
# d) FAIL: when ElasticSearch Domain Resources have LogPublishingOptions.ES_APPLICATION_LOGS.Enabled set to a value other than true 
# e) FAIL: when ElasticSearch Domain Resources have LogPublishingOptions.ES_APPLICATION_LOGS.CloudWatchLogsLogGroupArn set to a value other than a string or struct  
# f) PASS: when ElasticSearch Domain Resources have LogPublishingOptions.ES_APPLICATION_LOGS.Enabled set to true and 
#          LogPublishingOptions.ES_APPLICATION_LOGS.CloudWatchLogsLogGroupArn set to a string or struct value  

#
# Select all ElasticSearch domains from incoming template
#
let elasticsearch_audit_logging_enabled = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_APPLICATION_LOGGING_ENABLED"
]

rule ELASTICSEARCH_APPLICATION_LOGGING_ENABLED when %elasticsearch_audit_logging_enabled !empty {
    %elasticsearch_audit_logging_enabled.Properties { 
        LogPublishingOptions exists
        LogPublishingOptions is_struct

        LogPublishingOptions {
            ES_APPLICATION_LOGS exists
            ES_APPLICATION_LOGS is_struct

            ES_APPLICATION_LOGS {
                Enabled exists
                Enabled == true
                    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                        Violation: Elasticsearch domains are are configured to send application logs to Amazon CloudWatch Logs
                        Fix: In LogPublishingOptions.ES_APPLICATION_LOGS, set Enabled to true and CloudWatchLogsLogGroupArn to the ARN of a Amazon CloudWatch Logs log group.
                    >>
                CloudWatchLogsLogGroupArn exists
                CloudWatchLogsLogGroupArn is_string or
                CloudWatchLogsLogGroupArn is_struct
                    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                        Violation: Elasticsearch domains are are configured to send application logs to Amazon CloudWatch Logs
                        Fix: In LogPublishingOptions.ES_APPLICATION_LOGS, set Enabled to true and CloudWatchLogsLogGroupArn to the ARN of a Amazon CloudWatch Logs log group.
                    >>
            }
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#  ELASTICSEARCH_LOGS_TO_CLOUDWATCH
#
# Description:
#   Checks if Amazon OpenSearch Service (OpenSearch Service) domains are
#   configured to send logs to Amazon CloudWatch Logs.
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there is no elasticsearch domain present
# b) SKIP: when metadata has rule suppression for ELASTICSEARCH_LOGS_TO_CLOUDWATCH
# c) FAIL: when Elasticsearch domain does not have LogPublishingOptions or Enabled parameter is set to false for all available keys
# d) PASS: when Elasticsearch domain has LogPublishingOptions with Enabled parameter is set to true on one key

#
# Select all Elasticsearch domains from incoming template
#
let elasticsearch_domains_logs_cloudwatch = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_LOGS_TO_CLOUDWATCH"
]

rule ELASTICSEARCH_LOGS_TO_CLOUDWATCH when %elasticsearch_domains_logs_cloudwatch !empty {

    %elasticsearch_domains_logs_cloudwatch.Properties.LogPublishingOptions EXISTS
    %elasticsearch_domains_logs_cloudwatch.Properties.LogPublishingOptions.ES_APPLICATION_LOGS.Enabled == true OR
    %elasticsearch_domains_logs_cloudwatch.Properties.LogPublishingOptions.SEARCH_SLOW_LOGS.Enabled == true OR
    %elasticsearch_domains_logs_cloudwatch.Properties.LogPublishingOptions.INDEX_SLOW_LOGS.Enabled == true
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
            Violation: Elasticsearch domain must have logging configured to send logs to CloudWatch Logs.
            Fix: Set a LogPublishingOptions object to have the property "Enabled" parameter set to true for keys "ES_APPLICATION_LOGS", "SEARCH_SLOW_LOGS", or "INDEX_SLOW_LOGS".
        >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   OPENSEARCH_HTTPS_REQUIRED
#
# Description:
#   OpenSearchService domains are configured to require HTTPS with a minimum TLS version of TLSv1.2
#
# Reports on:
#   AWS::OpenSearchService::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no OpenSearchService Domain Resources 
# b) SKIP: when metadata has rule suppression for OPENSEARCH_HTTPS_REQUIRED
# c) FAIL: when OpenSearchService Domain Resources are missing DomainEndpointOptions.EnforceHTTPS
# d) FAIL: when OpenSearchService Domain Resources are missing DomainEndpointOptions.TLSSecurityPolicy
# e) FAIL: when OpenSearchService Domain Resources have DomainEndpointOptions.EnforceHTTPS set to a value other than true 
# f) FAIL: when OpenSearchService Domain Resources have DomainEndpointOptions.TLSSecurityPolicy set to a value other than 'Policy-Min-TLS-1-2-2019-07'
# g) PASS: when OpenSearchService Domain Resources have DomainEndpointOptions.EnforceHTTPS set to true and 
#          DomainEndpointOptions.TLSSecurityPolicy set to 'Policy-Min-TLS-1-2-2019-07'

#
# Select all OpenSearchService domains from incoming template
#
let opensearch_https_required = Resources.*[ Type == "AWS::OpenSearchService::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "OPENSEARCH_HTTPS_REQUIRED"
]

rule OPENSEARCH_HTTPS_REQUIRED when %opensearch_https_required !empty {
    %opensearch_https_required.Properties { 
        DomainEndpointOptions exists
        DomainEndpointOptions is_struct

        DomainEndpointOptions {
            EnforceHTTPS exists
            EnforceHTTPS == true
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: OpenSearchService domains are configured to require HTTPS with a minimum TLS version of TLSv1.2
                    Fix: In DomainEndpointOptions, set EnforceHTTPS to true and TLSSecurityPolicy to 'Policy-Min-TLS-1-2-2019-07'
                >>
            TLSSecurityPolicy exists
            TLSSecurityPolicy in [ "Policy-Min-TLS-1-2-2019-07" ]
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: OpenSearchService domains are configured to require HTTPS with a minimum TLS version of TLSv1.2
                    Fix: In DomainEndpointOptions, set EnforceHTTPS to true and TLSSecurityPolicy to 'Policy-Min-TLS-1-2-2019-07'
                >>
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK
#
# Description:
#   Elasticsearch domains must enforce Node-to-Node Encryption
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there is no elasticsearch domain present
# b) SKIP: when metada has rule suppression for ELASTICSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK
# c) FAIL: when Elasticsearch domain has Node-to-Node encryption property missing
# d) FAIL: when Elasticsearch domain has Node-to-Node encryption set to false
# e) PASS: when Elasticsearch domain has Node-to-Node encryption set to true

#
# Select all elasticsearch domains from incoming template
#
let elasticsearch_node_to_node_encryption_check = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK"
]

rule ELASTICSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK when %elasticsearch_node_to_node_encryption_check !empty {
    %elasticsearch_node_to_node_encryption_check.Properties.NodeToNodeEncryptionOptions.Enabled == true
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
            Violation: Elasticsearch domains must enforce Node-to-Node Encryption.
            Fix: Set the NodeToNodeEncryptionOptions.Enabled parameter to true.
        >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   OPENSEARCH_ACCESS_CONTROL_ENABLED
#
# Description:
#   OpenSearchService domains are are configured with fine-grained access control enabled
#
# Reports on:
#   AWS::OpenSearchService::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no OpenSearchService Domain Resources 
# b) SKIP: when metadata has rule suppression for OPENSEARCH_ACCESS_CONTROL_ENABLED
# c) FAIL: when OpenSearchService Domain Resources are missing AdvancedSecurityOptions.Enabled
# d) FAIL: when OpenSearchService Domain Resources have AdvancedSecurityOptions.Enabled set to a value other than true
# e) PASS: when OpenSearchService Domain Resources have AdvancedSecurityOptions.Enabled set to true

#
# Select all OpenSearchService domains from incoming template
#
let opensearch_access_control_enabled = Resources.*[ Type == "AWS::OpenSearchService::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "OPENSEARCH_ACCESS_CONTROL_ENABLED"
]

rule OPENSEARCH_ACCESS_CONTROL_ENABLED when %opensearch_access_control_enabled !empty {
    %opensearch_access_control_enabled.Properties { 
        AdvancedSecurityOptions exists
        AdvancedSecurityOptions is_struct

        AdvancedSecurityOptions {
            Enabled exists
            Enabled == true
                <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                    Violation: OpenSearchService domains are are configured with fine-grained access control enabled
                    Fix: In AdvancedSecurityOptions, set the Enabled property to true
                >>
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   OPENSEARCH_AUDIT_LOGGING_ENABLED
#
# Description:
#   OpenSearchService domains are are configured to send audit logs to Amazon CloudWatch Logs
#
# Reports on:
#   AWS::OpenSearchService::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no OpenSearchService Domain Resources 
# b) SKIP: when metadata has rule suppression for OPENSEARCH_AUDIT_LOGGING_ENABLED
# c) FAIL: when OpenSearchService Domain Resources are missing LogPublishingOptions.AUDIT_LOGS.Enabled or LogPublishingOptions.AUDIT_LOGS.CloudWatchLogsLogGroupArn
# d) FAIL: when OpenSearchService Domain Resources have LogPublishingOptions.AUDIT_LOGS.Enabled set to a value other than true 
# e) FAIL: when OpenSearchService Domain Resources have LogPublishingOptions.AUDIT_LOGS.CloudWatchLogsLogGroupArn set to a value other than a string or struct  
# f) PASS: when OpenSearchService Domain Resources have LogPublishingOptions.AUDIT_LOGS.Enabled set to true and 
#          LogPublishingOptions.AUDIT_LOGS.CloudWatchLogsLogGroupArn set to a string or struct value  

#
# Select all OpenSearchService domains from incoming template
#
let opensearch_audit_logging_enabled = Resources.*[ Type == "AWS::OpenSearchService::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "OPENSEARCH_AUDIT_LOGGING_ENABLED"
]

rule OPENSEARCH_AUDIT_LOGGING_ENABLED when %opensearch_audit_logging_enabled !empty {
    %opensearch_audit_logging_enabled.Properties { 
        LogPublishingOptions exists
        LogPublishingOptions is_struct

        LogPublishingOptions {
            AUDIT_LOGS exists
            AUDIT_LOGS is_struct

            AUDIT_LOGS {
                Enabled exists
                Enabled == true
                    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                        Violation: OpenSearchService domains are are configured to send audit logs to Amazon CloudWatch Logs
                        Fix: In LogPublishingOptions.AUDIT_LOGS, set Enabled to true and CloudWatchLogsLogGroupArn to the ARN of a Amazon CloudWatch Logs log group.
                    >>
                CloudWatchLogsLogGroupArn exists
                CloudWatchLogsLogGroupArn is_string or
                CloudWatchLogsLogGroupArn is_struct
                    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                        Violation: OpenSearchService domains are are configured to send audit logs to Amazon CloudWatch Logs
                        Fix: In LogPublishingOptions.AUDIT_LOGS, set Enabled to true and CloudWatchLogsLogGroupArn to the ARN of a Amazon CloudWatch Logs log group.
                    >>
            }
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_ENCRYPTED_AT_REST
#
# Description:
#   Elasticsearch domains must enforce server side encryption
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there is no Elasticsearch domain present
# b) SKIP: when metada has rule suppression for ELASTICSEARCH_ENCRYPTED_AT_REST
# c) FAIL: when Elasticsearch domain has server side encryption property is missing
# d) FAIL: when Elasticsearch domain has server side encryption set to false
# e) PASS: when Elasticsearch domain has server side encryption set to true

#
# Select all elasticsearch domains from incoming template
#
let elasticsearch_domains_encrypted = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_ENCRYPTED_AT_REST"
]

rule ELASTICSEARCH_ENCRYPTED_AT_REST when %elasticsearch_domains_encrypted !empty {
    %elasticsearch_domains_encrypted.Properties.EncryptionAtRestOptions.Enabled == true
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
            Violation: Elasticsearch domains must enforce server side encryption.
            Fix: Set the EncryptionAtRestOptions.Enabled parameter to true.
        >>
}
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   AUTOSCALING_GROUP_ELB_HEALTHCHECK_REQUIRED
#
# Description:
#   Checks whether your Auto Scaling groups that are associated with a load balancer are using Elastic Load Balancing health checks.
#
# Reports on:
#    AWS::AutoScaling::AutoScalingGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no Autoscaling Group resources present
# b) SKIP: when metada has rule suppression for AUTOSCALING_GROUP_ELB_HEALTHCHECK_REQUIRED
# c) SKIP: 'LoadBalancerNames' or 'TargetGroupARNs' are not present
# d) FAIL: 'HealthCheckType' is not present
# e) FAIL: 'HealthCheckType' is present and set to a value other than 'ELB'
# f) PASS: 'HealthCheckType' is present and set 'ELB'

#
# Select all Autoscaling Group Resources from incoming template
#
let autoscaling_group_elb_healthcheck_required_resources = Resources.*[ Type == "AWS::AutoScaling::AutoScalingGroup"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "AUTOSCALING_GROUP_ELB_HEALTHCHECK_REQUIRED"
]

rule AUTOSCALING_GROUP_ELB_HEALTHCHECK_REQUIRED when %autoscaling_group_elb_healthcheck_required_resources !empty {
    %autoscaling_group_elb_healthcheck_required_resources[
        # Scenario c)
        Properties {
            LoadBalancerNames exists
            LoadBalancerNames is_list
            LoadBalancerNames not empty
        } or
        Properties {
            TargetGroupARNs exists
            TargetGroupARNs is_list
            TargetGroupARNs not empty
        }
     ] {
        Properties {
            # Scenario d)
            HealthCheckType exists
            # Scenarios e) and f)
            HealthCheckType == "ELB"
            <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
                Violation: AWS AutoScaling Groups with Classic Load Balancer or Target Group associations must be configured with ELB healh checks.
                Fix: Set 'HealthCheckType' to 'ELB'
            >>
        }
    }
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    AUTOSCALING_LAUNCH_CONFIG_PUBLIC_IP_DISABLED
#
# Description:
#   Checks that Amazon EC2 Auto Scaling launch configurations are configured to not associate public IP addresses
#
# Reports on:
#    AWS::AutoScaling::LaunchConfiguration
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no AutoScaling::LaunchConfiguration resource present
# b) SKIP: when metada has rule suppression for AUTOSCALING_LAUNCH_CONFIG_PUBLIC_IP_DISABLED
# c) FAIL: when all AutoScaling::LaunchConfiguration resources AssociatePublicIpAddress property does not exist
# d) FAIL: when all AutoScaling::LaunchConfiguration resources have AssociatePublicIpAddress set to true
# e) PASS: when all AutoScaling::LaunchConfiguration resources AssociatePublicIpAddress property is set to false

#
# Select all AutoScaling Launch Configuration resources from incoming template (payload)
#
let autoscaling_launch_config_public_ip_disabled = Resources.*[ Type == "AWS::AutoScaling::LaunchConfiguration"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "AUTOSCALING_LAUNCH_CONFIG_PUBLIC_IP_DISABLED"
]

rule AUTOSCALING_LAUNCH_CONFIG_PUBLIC_IP_DISABLED when %autoscaling_launch_config_public_ip_disabled !empty {
    %autoscaling_launch_config_public_ip_disabled.Properties {
        AssociatePublicIpAddress exists
        AssociatePublicIpAddress == false
        <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
            Violation: Amazon EC2 Auto Scaling launch configurations are configured to not associate public IP addresses
            Fix: Explicitly set the AssociatePublicIpAddress attribute to false.
        >>
    }
}


#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    EFS_RESOURCES_PROTECTED_BY_BACKUP_PLAN
#
# Description:
#   Checks if Amazon Elastic File System (Amazon EFS) File Systems are protected by a backup plan.
#   The rule is NON_COMPLIANT if the EFS File System is not covered by a backup plan.
#
# Reports on:
#    AWS::EFS::FileSystem
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no EFS resource present
# b) PASS: when all EFS resources have backup policy set to ENABLED
# c) FAIL: when all EFS resources have backup policy Status to anything but ENABLED
# d) SKIP: when guard metadata states EFS_RESOURCES_PROTECTED_BY_BACKUP_PLAN to be suppressed

#
# Select all EFS resources from incoming template (payload)
#
let efs_file_systems_protected_by_backup_plan = Resources.*[ Type == 'AWS::EFS::FileSystem'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EFS_RESOURCES_PROTECTED_BY_BACKUP_PLAN"
]

rule EFS_RESOURCES_PROTECTED_BY_BACKUP_PLAN when %efs_file_systems_protected_by_backup_plan !empty {
  %efs_file_systems_protected_by_backup_plan.Properties.BackupPolicy.Status == 'ENABLED'
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: EFS filesystem backup policy should be enabled.
    Fix: Set the EFS Filesystem property BackupPolicy.Status parameter to ENABLED.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    EFS_ENCRYPTED_CHECK
#
# Description:
#   Checks if Amazon Elastic File System (Amazon EFS) is configured to encrypt the file data
#   using AWS Key Management Service (AWS KMS). The rule is NON_COMPLIANT if the encrypted
#   key is set to false on DescribeFileSystems or if the KmsKeyId key on DescribeFileSystems
#   does not match the KmsKeyId parameter.
#
# Reports on:
#    AWS::EFS::FileSystem
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no EFS resource present
# b) PASS: when all EFS resources have encrypted key property set to true
# c) FAIL: when all EFS resources have encrypted key property not set or set to false
# d) SKIP: when guard metadata states EFS_ENCRYPTED_CHECK to be suppressed

#
# Select all EFS resources from incoming template (payload)
#
let efs_file_systems_encrypted_check = Resources.*[ Type == 'AWS::EFS::FileSystem'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EFS_ENCRYPTED_CHECK"
]

rule EFS_ENCRYPTED_CHECK when %efs_file_systems_encrypted_check !empty {
  %efs_file_systems_encrypted_check.Properties.Encrypted == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: EFS filesystem must be encrypted.
    Fix: Set the EFS Filesystem property Encrypted parameter to true.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   IAM_USER_NO_POLICIES_CHECK
#
# Description:
#   Checks that none of your IAM users have policies attached. IAM users must inherit permissions from IAM groups or roles. 
#
# Reports on:
#   AWS::IAM::User
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no IAM Users present
# b) PASS: when all IAM Users do not have policies attached
# c) FAIL: when any IAM User have policies attached
# d) SKIP: when metada has rule suppression for IAM_USER_NO_POLICIES_CHECK

#
# Select all IAM User resources from incoming template (payload)
# 
let aws_iam_users_no_policies = Resources.*[ Type == 'AWS::IAM::User'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_USER_NO_POLICIES_CHECK" 
]

rule IAM_USER_NO_POLICIES_CHECK when %aws_iam_users_no_policies !empty {
  %aws_iam_users_no_policies.Properties.Policies empty
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
  	Violation: Inline policies are not allowed on IAM Users. IAM users must inherit permissions from IAM groups or roles.
  	Fix: Remove the Policies list property from any IAM Users. 
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   IAM_POLICY_NO_STATEMENTS_WITH_FULL_ACCESS
#
# Description:
#   Checks if AWS Identity and Access Management (IAM) policies grant permissions to all actions on individual AWS resources.
#
# Reports on:
#   AWS::IAM::ManagedPolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no IAM Managed Policies present
# b) PASS: when all IAM Managed Policies do not allows full access to at least 1 AWS service
# c) FAIL: when any IAM Managed Policies allows full access to at least 1 AWS service.
# d) SKIP: when metada has rule suppression for IAM_POLICY_NO_STATEMENTS_WITH_FULL_ACCESS

#
# Select all IAM Managed Policy resources from incoming template (payload)
# 
let aws_iam_managed_policies_no_statements_with_full_access = Resources.*[ Type == 'AWS::IAM::ManagedPolicy'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_POLICY_NO_STATEMENTS_WITH_FULL_ACCESS" 
]

rule IAM_POLICY_NO_STATEMENTS_WITH_FULL_ACCESS when %aws_iam_managed_policies_no_statements_with_full_access !empty {
  let violations = Resources.*[
    Type == 'AWS::IAM::ManagedPolicy' 
    some Properties.PolicyDocument.Statement[*] {
      some Action[*] in ["*", /^[a-zA-Z0-9]*:\*$/]
      Effect == "Allow"
      some Resource in ["*"]
    }
  ]
  %violations empty
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: One or more IAM Managed Policies allow full access to at least 1 AWS service
    Fix: Remove policy statements that match {"Effect": "Allow", "Action": "<service-name>:*" ... } or {"Effect": "Allow", "Action": "*" ... }
  >>
} 
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   IAM_POLICY_NO_STATEMENTS_WITH_ADMIN_ACCESS
#
# Description:
#   Checks the IAM policies that you create for Allow statements that grant permissions to all actions on all resources. 
#
# Reports on:
#   AWS::IAM::Policy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no IAM Policies present
# b) PASS: when all IAM Policies do not grant permissions to all actions on all resources
# c) FAIL: when any IAM Policies grant permissions to all actions on all resources
# d) SKIP: when metada has rule suppression for IAM_POLICY_NO_STATEMENTS_WITH_ADMIN_ACCESS

#
# Select all IAM Policy resources from incoming template (payload)
# 
let aws_iam_policies_no_statements_with_admin_access = Resources.*[ Type == 'AWS::IAM::Policy' 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_POLICY_NO_STATEMENTS_WITH_ADMIN_ACCESS"
]

rule IAM_POLICY_NO_STATEMENTS_WITH_ADMIN_ACCESS when %aws_iam_policies_no_statements_with_admin_access !empty {
  let violations = Resources.*[
    Type == 'AWS::IAM::Policy' 
    some Properties.PolicyDocument.Statement[*] {
      some Action[*] == "*"
      Effect == "Allow"
      some Resource in ["*"]
    }
  ]
  %violations empty
	<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: One or more IAM policies contain allow statements that grant permissions to all actions on all resources
    Fix: Remove policy statements that match {"Effect": "Allow", "Action": "*", "Resource": "*"}
  >>
} 



#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   IAM_NO_INLINE_POLICY_CHECK 
#
# Description:
#   Checks that inline policy feature is not in use.
#
# Reports on:
#   AWS::IAM::User
#   AWS::IAM::Role
#   AWS::IAM::Group
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no IAM Users, Roles, or Groups present
# b) PASS: when all IAM Users, Roles, or Groups present have no inline policies listed
# c) FAIL: when any IAM Users, Roles, or Groups present have inline policies listed
# d) SKIP: when metada has rule suppression for IAM_NO_INLINE_POLICY_CHECK

#
# Select all IAM User, Role, and Group resources from incoming template (payload)
#
let aws_iam_entities_no_inline_policy = Resources.*[
  Type in [ /AWS::IAM::User/,
            /AWS::IAM::Role/,
            /AWS::IAM::Group/ ]
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_NO_INLINE_POLICY_CHECK"
]

rule IAM_NO_INLINE_POLICY_CHECK when %aws_iam_entities_no_inline_policy !empty {
  %aws_iam_entities_no_inline_policy.Properties.Policies empty
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: Inline policies are not allowed on IAM Users, Roles, or Groups.
    Fix: Remove the Policies list property from any IAM Users, Roles, or Groups.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RESTRICTED_INCOMING_TRAFFIC
#
# Description:
#    Checks if the security groups in use do not allow unrestricted incoming TCP traffic to the specified ports. 
#
# Reports on:
#    AWS::EC2::SecurityGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no Security Groups resource present
# b) SKIP when there are no TCP or UDP ingress rules
# c) PASS: when all Security Groups do no allow any of the restricted common ports
# d) FAIL: when a Security Group allows any of the restricted common ports
# e) SKIP: when metadata includes the suppression for rule RESTRICTED_INCOMING_TRAFFIC

#
# Select all Security Group resources from incoming template (payload)
#
let aws_security_groups_restricted_incoming_traffic = Resources.*[ Type == 'AWS::EC2::SecurityGroup' 
	some Properties.SecurityGroupIngress[*] {
		IpProtocol in ['tcp', 'udp']
	}
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RESTRICTED_INCOMING_TRAFFIC"
]

rule RESTRICTED_INCOMING_TRAFFIC when %aws_security_groups_restricted_incoming_traffic !empty {
	let violations = Resources.*[
		Type == 'AWS::EC2::SecurityGroup'
		some Properties.SecurityGroupIngress[*] {
			FromPort in [ 20, 21, 3389, 3306, 4333 ]
      ToPort in [ 20, 21, 3389, 3306, 4333 ]
		}
	]
	%violations empty 
	<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
		Violation: Security groups must not allow unrestricted incoming TCP/UDP traffic to the specified ports [20, 21, 3389, 3306, 4333].
		Fix: change the FromPort and ToPort properties in the SecurityGroupIngress list 
	>>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    EC2_INSTANCES_IN_VPC
#
# Description:
#    Checks if your EC2 instances belong to a virtual private cloud (VPC).
#
# Reports on:
#    AWS::EC2::Instance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no EC2 resource present
# b) PASS: when all EC2 resources have the SubnetId property set
# c) FAIL: when any EC2 resources do not have the SubnetId property set
# d) SKIP: when metadata includes the suppression for rule EC2_INSTANCES_IN_VPC

#
# Select all ECS Instance resources from incoming template (payload)
#
let ec2_instances_in_vpc = Resources.*[ Type == 'AWS::EC2::Instance' 
  Metadata.guard.SuppressedRules not exists or 
  Metadata.guard.SuppressedRules.* != "EC2_INSTANCES_IN_VPC"
]

rule EC2_INSTANCES_IN_VPC when %ec2_instances_in_vpc !empty {
  %ec2_instances_in_vpc.Properties.SubnetId !empty
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
  	Violation: EC2 Instances must belong to a VPC
  	Fix: set the SubnetId property to a subnet ID
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    EC2_EBS_ENCRYPTION_BY_DEFAULT
#
# Description:
#    Check that Amazon Elastic Block Store (EBS) encryption is enabled by default
# Reports on:
#    AWS::EC2::Volume
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no EC2 Volume resources are present
# b) PASS: when all EC2 Volume resources have the Encrypted property set to true
# c) FAIL: when any EC2 Volumes resources do not have the Encrypted property set to true
# e) SKIP: when metadata includes the suppression for rule EC2_EBS_ENCRYPTION_BY_DEFAULT

#
# Select all EC2 Volume resources from incoming template (payload)
#
let ec2_ebs_volumes_encrypted_by_default = Resources.*[ Type == 'AWS::EC2::Volume' 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_EBS_ENCRYPTION_BY_DEFAULT"
]

rule EC2_EBS_ENCRYPTION_BY_DEFAULT when %ec2_ebs_volumes_encrypted_by_default !empty {
    %ec2_ebs_volumes_encrypted_by_default.Properties.Encrypted == true 
		<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
			Violation: All EBS Volumes should be encryped 
			Fix: Set Encrypted property to true
		>>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    EC2_INSTANCE_DETAILED_MONITORING_ENABLED
#
# Description:
#    Checks if detailed monitoring is enabled for EC2 instances. 
#
# Reports on:
#    AWS::EC2::Instance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no EC2 resource present
# b) PASS: when all EC2 resources have the Monitoring property set to true
# c) FAIL: when any EC2 resources do not have the Monitoring property set to true
# d) SKIP: hen metadata includes the suppression for rule EC2_INSTANCE_DETAILED_MONITORING_ENABLED

#
# Select all EC2 Instance resources from incoming template (payload)
#
let ec2_instances_detailed_monitoring_enabled = Resources.*[ Type == 'AWS::EC2::Instance' 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_INSTANCE_DETAILED_MONITORING_ENABLED"
]

rule EC2_INSTANCE_DETAILED_MONITORING_ENABLED when %ec2_instances_detailed_monitoring_enabled !empty {
    %ec2_instances_detailed_monitoring_enabled.Properties.Monitoring == true 
    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
      Violation: EC2 Instance Monitoring must be enabled on all EC2 instances
      Fix: set the Monitoring property to true
    >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    SUBNET_AUTO_ASSIGN_PUBLIC_IP_DISABLED
#
# Description:
#    Checks if Amazon Virtual Private Cloud (Amazon VPC) subnets are assigned a public IP address.  
#
# Reports on:
#    AWS::EC2::Subnet
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no EC2 Subnet resource present
# b) PASS: when all EC2 Subnet resources have the MapPublicIpOnLaunch property set to false or it is missing (default false)
# c) FAIL: when any EC2 Subnet resources have the MapPublicIpOnLaunch property set to true
# d) SKIP: hen metadata includes the suppression for rule SUBNET_AUTO_ASSIGN_PUBLIC_IP_DISABLED

#
# Select all EC2 Subnet resources from incoming template (payload)
#
let ec2_subnets_auto_assign_public_ip_disabled = Resources.*[ Type == 'AWS::EC2::Subnet' 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SUBNET_AUTO_ASSIGN_PUBLIC_IP_DISABLED"
]

rule SUBNET_AUTO_ASSIGN_PUBLIC_IP_DISABLED when %ec2_subnets_auto_assign_public_ip_disabled !empty {
	%ec2_subnets_auto_assign_public_ip_disabled.Properties.MapPublicIpOnLaunch !exists
  OR %ec2_subnets_auto_assign_public_ip_disabled.Properties.MapPublicIpOnLaunch == false
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: VPCs should not have subnets that are assigned a public IP address.
    Fix: remove the MapPublicIpOnLaucnh property or set it to false
	>>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    NO_UNRESTRICTED_ROUTE_TO_IGW
#
# Description:
#    Checks if there are public routes in the route table to an Internet Gateway (IGW). 
#
# Reports on:
#    AWS::EC2::Route
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no EC2 Route resources are present
# b) SKIP: when there are no EC2 Routes to an Internet Gateway (no GatewayId property)
# c) PASS: when all EC2 Routes to an Internet Gateway have a restricted destination CIDR block (not '0.0.0.0/0' or '::/0')
# d) FAIL: when any EC2 Routes to an Internet Gateway have a destination CIDR block of '0.0.0.0/0' or '::/0' 
# e) SKIP: hen metadata includes the suppression for rule NO_UNRESTRICTED_ROUTE_TO_IGW

#
# Select all EC2 Route resources from incoming template (payload)
#
let routes_no_unrestricted_to_igw = Resources.*[ Type == 'AWS::EC2::Route' 
	Properties.GatewayId exists
	Metadata.guard.SuppressedRules not exists or	
  Metadata.guard.SuppressedRules.* != "NO_UNRESTRICTED_ROUTE_TO_IGW"
]

rule NO_UNRESTRICTED_ROUTE_TO_IGW when %routes_no_unrestricted_to_igw !empty {
	%routes_no_unrestricted_to_igw {
		Properties {
			DestinationCidrBlock not in ['0.0.0.0/0', '::/0']
			<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
				Violation: EC2 Routes to an IGW cannot have a destination CIDR block of '0.0.0.0/0' or '::/0' 
				Fix: Remove routes to an IGW (with the GatewayId property defined) or modify the DestinationCidrBlock property to a more restricted CIDR block
			>>
		}
	}
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    ENCRYPTED_VOLUMES
#
# Description:
#    Checks if the EBS volumes that are in an attached state are encrypted. 
#
# Reports on:
#    AWS::EC2::Volume
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no EBS volume resources present
# b) PASS: when all EBS volumes have the KmsKeyId property set or the Encrypted property set to true 
# c) FAIL: when any EC2 volumes do not have the KmsKeyId or Encrypted property set
# e) SKIP: hen metadata includes the suppression for rule ENCRYPTED_VOLUMES

#
# Select all EC2 Instance resources from incoming template (payload)
#
let ebs_volumes_encrypted = Resources.*[ Type == 'AWS::EC2::Volume' 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ENCRYPTED_VOLUMES"
]

rule ENCRYPTED_VOLUMES when %ebs_volumes_encrypted !empty {
  %ebs_volumes_encrypted.Properties.KmsKeyId !empty
	OR %ebs_volumes_encrypted.Properties.Encrypted == true
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: EBS volumes in an attached state must encrypted.
    Fix: either set the KmsKeyId property to a key ID, key alias, key ARN, or alias ARN 
		or set the Encrypted property to true to encrypt the volume with the account default key or AWS managed key. 
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    INCOMING_SSH_DISABLED
#
# Description:
#    Checks if the incoming SSH traffic for the security groups is accessible. 
#
# Reports on:
#    AWS::EC2::SecurityGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no Security Group resources are present
# b) SKIP: when no SSH ingress is defined (port 22)
# c) PASS: when all Security Groups resources restrict the IP address of the incoming SSH traffic
# d) FAIL: when a Security Group allows SSH traffic from any IP address (0.0.0.0/0). 
# e) SKIP: hen metadata includes the suppression for rule INCOMING_SSH_DISABLED

#
# Select all Security Group resources from incoming template (payload)
#
let aws_security_groups_restricted_ssh = Resources.*[ 
	Type == 'AWS::EC2::SecurityGroup'
	some Properties.SecurityGroupIngress[*] {
		ToPort == 22
		FromPort == 22
		IpProtocol == "tcp"
	}
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "INCOMING_SSH_DISABLED"
]

rule INCOMING_SSH_DISABLED when %aws_security_groups_restricted_ssh !empty {
	%aws_security_groups_restricted_ssh.Properties.SecurityGroupIngress[*] != {CidrIp:"0.0.0.0/0", ToPort:22, FromPort:22, IpProtocol:"tcp"}
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: IP addresses of the incoming SSH traffic in the security groups are restricted (CIDR other than 0.0.0.0/0)
    Fix: set SecurityGroupIngress.CidrIp property to a more restrictive CIDR than 0.0.0.0/0
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    EC2_INSTANCE_NO_PUBLIC_IP
#
# Description:
#    Checks whether Amazon Elastic Compute Cloud (Amazon EC2) instances have a public IP association. 
#
# Reports on:
#    AWS::EC2::Instance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no EC2 Instance resources are present
# b) SKIP: when no EC2 Instances have network interfaces defined
# c) PASS: when no EC2 Instances with network interfaces have associated public IP addresses
# d) FAIL: when any EC2 Instances with network interfaces have associated public IP addresses
# e) SKIP: hen metadata includes the suppression for rule EC2_INSTANCE_NO_PUBLIC_IP

#
# Select all EC2 Instance resources from incoming template (payload)
#
let ec2_instances_no_public_ip = Resources.*[Type == 'AWS::EC2::Instance'
	Properties.NetworkInterfaces[*] !empty 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_INSTANCE_NO_PUBLIC_IP"
]

rule EC2_INSTANCE_NO_PUBLIC_IP when %ec2_instances_no_public_ip !empty {
	%ec2_instances_no_public_ip.Properties.NetworkInterfaces[*] {
		AssociatePublicIpAddress !exists OR 
		AssociatePublicIpAddress == false
		<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    	Violation: EC2 Instances cannot have public IP addresses associated with their network interfaces 
    	Fix: remove the AssociatePublicIpAddress property from NetworkInterfaces list or set it to false
  	>>
	}
}


#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    EBS_OPTIMIZED_INSTANCE
#
# Description:
#    Checks whether EBS optimization is enabled for your EC2 instances that can be EBS-optimized 
#
# Reports on:
#    AWS::EC2::Instance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no EC2 resource present
# b) PASS: when all EC2 resources EbsOptimized property is set to true
# c) FAIL: when any EC2 resources do not have the EbsOptimized property set to true
# e) SKIP: hen metadata includes the suppression for rule EBS_OPTIMIZED_INSTANCE

#
# Select all AWS EC2 Instance resources from incoming template (payload)
#
let ec2_ebs_optimized_instances = Resources.*[ Type == 'AWS::EC2::Instance' 
	Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EBS_OPTIMIZED_INSTANCE"
]

rule EBS_OPTIMIZED_INSTANCE when %ec2_ebs_optimized_instances !empty {
    %ec2_ebs_optimized_instances.Properties.EbsOptimized == true
    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
			Violation: EBS optimization must be enabled for your EC2 instances
			Fix: set the EbsOptimized property to true
    >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    EC2_INSTANCE_PROFILE_ATTACHED
#
# Description:
#    Checks if an Amazon Elastic Compute Cloud (Amazon EC2) instance has an Identity and Access Management (IAM) profile attached to it. 
#
# Reports on:
#    AWS::EC2::Instance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no EC2 Instance resources are present 
# b) PASS: when all EC2 Instace resources have an associated IAM instance profile 
# d) FAIL: when any EC2 Instace resources do not have an associated IAM instance profile
# e) SKIP: hen metadata includes the suppression for rule EC2_INSTANCE_PROFILE_ATTACHED

#
# Select all EC2 Instance resources from incoming template (payload)
#
let ec2_instances_profile_attached = Resources.*[ Type == 'AWS::EC2::Instance' 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_INSTANCE_PROFILE_ATTACHED"
]

rule EC2_INSTANCE_PROFILE_ATTACHED when %ec2_instances_profile_attached !empty {
  %ec2_instances_profile_attached.Properties.IamInstanceProfile EXISTS
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: EC2 Instances must have IAM profile attached to it.
    Fix: Associate the EC2 Instance property IamInstanceProfile with an IAM Instance Profile.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    LAMBDA_INSIDE_VPC
#
# Description:
#    Checks whether an AWS Lambda function is allowed access to an Amazon Virtual Private Cloud.
#
# Reports on:
#    AWS::Lambda::Function
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no AWS Lambda functions are present
# b) PASS: when all AWS Lambda functions are VPC enabled
# c) FAIL: when any AWS Lambda functions are not VPC enabled
# d) SKIP: hen metadata includes the suppression for rule LAMBDA_INSIDE_VPC

#
# Select all AWS Lambda Function resources from incoming template (payload)
#
let aws_lambda_functions_inside_vpc = Resources.*[ Type == 'AWS::Lambda::Function' 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "LAMBDA_INSIDE_VPC"
]

rule  LAMBDA_INSIDE_VPC when %aws_lambda_functions_inside_vpc !empty {
  %aws_lambda_functions_inside_vpc.Properties.VpcConfig.SecurityGroupIds !empty
  %aws_lambda_functions_inside_vpc.Properties.VpcConfig.SubnetIds !empty
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation:  All AWS Lambda Functions must be configured with access to a VPC
    Fix: set the VpcConfig.SecurityGroupIds and VpcConfig.SubnetIds parameters with a list of security groups and subnets.
    Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    LAMBDA_CONCURRENCY_CHECK
#
# Description:
#    Checks whether the AWS Lambda function is configured with function-level concurrent execution limit.
#
# Reports on:
#    AWS::Lambda::Function
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no AWS Lambda functions are present
# b) PASS: when all AWS Lambda functions are configured with function-level concurrent execution limits
# c) FAIL: when any AWS Lambda functions are not configured with function-level concurrent execution limits
# d) SKIP: hen metadata includes the suppression for rule LAMBDA_CONCURRENCY_CHECK

#
# Select all AWS Lambda Function resources from incoming template (payload)
#
let aws_lambda_functions_concurrency = Resources.*[ Type == 'AWS::Lambda::Function' 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "LAMBDA_CONCURRENCY_CHECK"
]

rule LAMBDA_CONCURRENCY_CHECK when %aws_lambda_functions_concurrency !empty {
  %aws_lambda_functions_concurrency.Properties.ReservedConcurrentExecutions >= 0
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: All AWS Lambda Functions must have concurrent execution limits configured
    Fix: Set the ReservedConcurrentExecutions property to an integer greater than or equal to 0
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    LAMBDA_FUNCTION_PUBLIC_ACCESS_PROHIBITED
#
# Description:
#    Checks if the AWS Lambda function policy attached to the Lambda resource prohibits public access.
#
# Reports on:
#    AWS::Lambda::Permission
#    AWS::Lambda::LayerVersionPermission
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no AWS Lambda permission policies are present
# b) PASS: when all AWS Lambda permission policies prohibit public access
# c) FAIL: when any AWS Lambda permission policies allow public access
# d) SKIP: hen metadata includes the suppression for rule LAMBDA_FUNCTION_PUBLIC_ACCESS_PROHIBITED

#
# Select all AWS Lambda Permission resources from incoming template (payload)
#
let aws_lambda_permissions_public_access_prohibited = Resources.*[
  Type in [ /AWS::Lambda::Permission/,
    /AWS::Lambda::LayerVersionPermission/ ]
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "LAMBDA_FUNCTION_PUBLIC_ACCESS_PROHIBITED"
]

rule LAMBDA_FUNCTION_PUBLIC_ACCESS_PROHIBITED when %aws_lambda_permissions_public_access_prohibited !empty {

  # Lambda permission policy where principal is an account id
  %aws_lambda_permissions_public_access_prohibited {
    Type == 'AWS::Lambda::Permission'
    Properties {
      Principal in [ /^\d{12}$/, {"Ref":"AWS::AccountId"} ]
      OR Principal > 0
    }
  }

  # Lambda permission policy where principal is a service (not s3)
  OR %aws_lambda_permissions_public_access_prohibited {
    Type == 'AWS::Lambda::Permission'
    Properties {
      Principal != 's3.amazonaws.com'
      PrincipalOrgID !empty
      OR SourceAccount exists
      OR SourceArn !empty
      <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
        Violation: All Lambda permission policies attached to Lambda resources must prohibit public access.
        Fix: Limit permission policies by setting the Principal property to an account ID,
        or limiting a service principal by setting the SourceArn, SourceAccount, or PrincipalOrgID properties.
      >>
    }
  }

  # Lambda permission policy where principal is s3 service
  OR %aws_lambda_permissions_public_access_prohibited {
    Type == 'AWS::Lambda::Permission'
    Properties {
      Principal == 's3.amazonaws.com'
      PrincipalOrgID !empty
      OR SourceAccount exists
      <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
        Violation: All Lambda permission policies attached to Lambda resources must prohibit public access.
        Fix: Limit permission policies by setting the Principal property to an account ID,
        or for S3 as the principal specify either a SourceAccount or PrincipalOrgID.
        Note: It is possible for an S3 bucket to be deleted by its owner and recreated by another account.
      >>
    }
  }

  # Lambda layer version permission policies
  OR %aws_lambda_permissions_public_access_prohibited {
    Type == 'AWS::Lambda::LayerVersionPermission'
    Properties {
      OrganizationId !empty
      OR Principal in [ /^\d{12}$/, {"Ref":"AWS::AccountId"} ]
      OR Principal > 0
      <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
        Violation: All Lambda permission policies attached to Lambda resources must prohibit public access.
        Fix: For Lambda layer version permission policies, either limit permissions by the OrganizationId property
        or set the Principal property to an account ID rather than using a wildcard (*).
      >>
    }
  }
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    LAMBDA_DLQ_CHECK
#
# Description:
#    Checks whether an AWS Lambda function is configured with a dead-letter queue.
#
# Reports on:
#    AWS::Lambda::Function
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no AWS Lambda functions are present
# b) PASS: when all AWS Lambda functions are configured with a dead-letter queue
# c) FAIL: when any AWS Lambda functions are not configured with a dead-letter queue
# d) SKIP: hen metadata includes the suppression for rule LAMBDA_DLQ_CHECK

#
# Select all AWS Lambda Function resources from incoming template (payload)
#
let aws_lambda_functions_dlq = Resources.*[ Type == 'AWS::Lambda::Function' 
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "LAMBDA_DLQ_CHECK"
]

rule LAMBDA_DLQ_CHECK when %aws_lambda_functions_dlq !empty {
  %aws_lambda_functions_dlq.Properties.DeadLetterConfig.TargetArn !empty
  <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: All AWS Lambda Functions must have a dead-letter queue configured
    Fix: Set the DeadLetterConfig.TargetAr Property to the Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic
  >>
}
## Config Rule Name : backup-plan-min-frequency-and-min-retention-check
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/backup-plan-min-frequency-and-min-retention-check.html"

## Config Rule Name : kms-cmk-not-scheduled-for-deletion
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/kms-cmk-not-scheduled-for-deletion.html"

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    CMK_BACKING_KEY_ROTATION_ENABLED
#
# Description:
#   Key rotation should be enabled for KMS
#
# Reports on:
#    AWS::KMS::Key
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no KMS CMKs
# b) SKIP: when metada has rule suppression for CMK_BACKING_KEY_ROTATION_ENABLED
# c) FAIL: when EnableKeyRotation is missing for any KMS CMKs
# d) FAIL: when EnableKeyRotation is set to false for any KMS CMKs
# e) PASS: when EnableKeyRotation is set to true on all KMS CMKs

#
# Select all KMS Key resources from incoming template (payload)
#

let cmk_backing_key_rotation_enabled = Resources.*[ Type == "AWS::KMS::Key"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CMK_BACKING_KEY_ROTATION_ENABLED"
]


rule CMK_BACKING_KEY_ROTATION_ENABLED when %cmk_backing_key_rotation_enabled !empty {
     %cmk_backing_key_rotation_enabled.Properties.EnableKeyRotation == true
      <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
        Violation: Key rotation should be enabled for KMS keys.
        Fix: Set the EnableKeyRotation property to true.
      >>
}
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    DAX_ENCRYPTION_ENABLED
#
# Description:
#  Checks whether the GitHub or Bitbucket source repository URL contains either personal access tokens or user name and password.
#
# Reports on:
#    AWS::CodeBuild::Project"
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no AWS::DAX::Cluster resources
# b) SKIP: when metada has rule suppression for DAX_ENCRYPTION_ENABLED
# c) FAIL: when SSESpecification does not exist or SSEEnabled not set to true
# d) PASS: when SSESpecification exist with the attribute SSEEnabled set to true

#
# Select all dax cluster resources from incoming template (payload)
#

let dax_clusters_encryption = Resources.*[ Type == "AWS::DAX::Cluster"
	Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DAX_ENCRYPTION_ENABLED"
]

rule DAX_ENCRYPTION_ENABLED when %dax_clusters_encryption !empty {
	%dax_clusters_encryption.Properties.SSESpecification.SSEEnabled == true
	<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
		Violation: Amazon DAX clusters are configured with encryption at rest
		Fix: In SSESpecification, set the SSEEnabled property to true
	>>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    ELASTICACHE_REDIS_CLUSTER_AUTOMATIC_BACKUP_CHECK
#
# Description:
#   Checks if Amazon DynamoDB table is encrypted with AWS Key Management Service (KMS).
#
# Reports on:
#    AWS::ElastiCache::ReplicationGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no AWS::ElastiCache::ReplicationGroup resources present
# b) PASS: when all DynamoDB Tables are encrypted with KMS
# c) FAIL: when all DynamoDB Tables are not are encrypted with KMS
# d) SKIP: when metada has rule suppression for ELASTICACHE_REDIS_CLUSTER_AUTOMATIC_BACKUP_CHECK

let replication_groups_automatedbackup = Resources.*[Type == "AWS::ElastiCache::ReplicationGroup"
	Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICACHE_REDIS_CLUSTER_AUTOMATIC_BACKUP_CHECK"
]

rule ELASTICACHE_REDIS_CLUSTER_AUTOMATIC_BACKUP_CHECK when %replication_groups_automatedbackup !empty {
	%replication_groups_automatedbackup.Properties.Engine != "redis" or
	%replication_groups_automatedbackup.Properties.SnapshotRetentionLimit > 0
	<<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
		Violation: Amazon ElastiCache Replication Groups are configured with automatic backups
		Fix: Set SnapshotRetentionLimit to value greater than zero
	>>
}

## Config Rule Name : acm-certificate-expiration-check
## Config Rule URL: https://docs.aws.amazon.com/config/latest/developerguide/acm-certificate-expiration-check.html"

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    EKS_ENDPOINT_NO_PUBLIC_ACCESS
#
# Description:
#   Checks whether Amazon Elastic Kubernetes Service (Amazon EKS) endpoint is not publicly accessible.
#
# Reports on:
#    AWS::EKS::Cluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no EKS clusters present
# b) PASS: when all EKS cluster endpoints are not publicly accessible
# c) FAIL: when any EKS cluster endpoints are publicly accessible
# d) SKIP: when metada has rule suppression for EKS_ENDPOINT_NO_PUBLIC_ACCESS

#
# Select all EKS cluster resources from incoming template (payload)
#

let amazon_eks_clusters_endpoint_no_public_access = Resources.*[ Type == 'AWS::EKS::Cluster'
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EKS_ENDPOINT_NO_PUBLIC_ACCESS"
]

rule EKS_ENDPOINT_NO_PUBLIC_ACCESS when %amazon_eks_clusters_endpoint_no_public_access !empty {
    # ensure the optional parameter is specified in the template
    %amazon_eks_clusters_endpoint_no_public_access.Properties.ResourcesVpcConfig.EndpointPublicAccess EXISTS
    # ensure the parameter is set to false
    %amazon_eks_clusters_endpoint_no_public_access.Properties.ResourcesVpcConfig.EndpointPublicAccess == false
    <<
    Guard Rule Set: guard-rules-registry-all-rules
    Controls: all rules in AWS Guard Rules Registry    
    Violation: EKS endpoint public access is not allowed.
    Fix: Set the boolean parameter ResourcesVpcConfig.EndpointPublicAccess to false
    >>
}
