/// AWS::WAFv2::RuleGroup
///
/// Generated by rain build --pkl-class AWS::WAFv2::RuleGroup
module aws.wafv2.rulegroup

import "../../cloudformation.pkl"

/// Sensitivity Level current only used for sqli match statements.
open class SensitivityLevel {
}

/// Field of the request to match.
open class FieldToMatch {
    Body: (Body)?
    Headers: (Headers)?
    Cookies: (Cookies)?
    SingleHeader: (Dynamic)?
    SingleQueryArgument: (Dynamic)?
    QueryString: (Dynamic)?
    Method: (Dynamic)?
    JsonBody: (JsonBody)?
    JA3Fingerprint: (JA3Fingerprint)?
    AllQueryArguments: (Dynamic)?
    UriPath: (Dynamic)?
}

/// ARN of the WAF entity.
open class ResourceArn {
}

/// 
open class Tag {
    Key: (String|Mapping)?
    Value: (String|Mapping)?
}

/// Checks valid token exists with request.
open class CaptchaAction {
    CustomRequestHandling: (CustomRequestHandling)?
}

/// Type of text transformation.
open class TextTransformationType {
}

/// Name of the Label.
open class LabelName {
}

/// 
open class AndStatement {
    Statements: Listing<Statement>
}

typealias ForwardedIPConfigurationFallbackBehavior = "MATCH"|"NO_MATCH"

/// 
open class ForwardedIPConfiguration {
    HeaderName: String(matches(Regex(#"^[a-zA-Z0-9-]+{1,255}$"#)))|Mapping
    FallbackBehavior: ForwardedIPConfigurationFallbackBehavior|Mapping
}

/// Action taken when Rule matches its condition.
open class RuleAction {
    Allow: (AllowAction)?
    Block: (BlockAction)?
    Count: (CountAction)?
    Captcha: (CaptchaAction)?
    Challenge: (ChallengeAction)?
}

/// HTTP header.
open class CustomHTTPHeader {
    Name: CustomHTTPHeaderName
    Value: CustomHTTPHeaderValue
}

/// Priority of the Rule, Rules get evaluated from lower to higher priority.
open class RulePriority {
}

/// Specifies a header as an aggregate key for a rate-based rule.
open class RateLimitHeader {
    Name: String(matches(Regex(#".*\S.*"#)))|Mapping
    TextTransformations: Listing<TextTransformation>
}

/// Specifies a label namespace to use as an aggregate key for a rate-based rule.
open class RateLimitLabelNamespace {
    Namespace: String(matches(Regex(#"^[0-9A-Za-z_:-]{1,1024}$"#)))|Mapping
}

/// Specifies a query argument in the request as an aggregate key for a rate-based rule.
open class RateLimitQueryArgument {
    Name: String(matches(Regex(#".*\S.*"#)))|Mapping
    TextTransformations: Listing<TextTransformation>
}

/// JSON pointer path in the web request's JSON body
open class JsonPointerPath {
}

/// 
open class RegexPatternSetReferenceStatement {
    Arn: ResourceArn
    FieldToMatch: FieldToMatch
    TextTransformations: Listing<TextTransformation>
}

/// Rule of RuleGroup that contains condition and action.
open class Rule {
    Statement: Statement
    Action: (RuleAction)?
    RuleLabels: (Listing<Label>)?
    VisibilityConfig: VisibilityConfig
    CaptchaConfig: (CaptchaConfig)?
    ChallengeConfig: (ChallengeConfig)?
    Name: EntityName
    Priority: RulePriority
}

/// Custom response key and body map.
open class CustomResponseBodies {
}

/// 
open class RuleGroup {
    Arn: (ResourceArn)?
    Description: (EntityDescription)?
    Rules: (Listing<Rule>)?
    VisibilityConfig: (VisibilityConfig)?
    Capacity: (Int|Mapping)?
    Name: (EntityName)?
    Id: (EntityId)?
}

/// Byte Match statement.
open class ByteMatchStatement {
    FieldToMatch: FieldToMatch
    TextTransformations: Listing<TextTransformation>
    PositionalConstraint: PositionalConstraint
    SearchString: (SearchString)?
    SearchStringBase64: (SearchStringBase64)?
}

/// 
open class OrStatement {
    Statements: Listing<Statement>
}

/// HTTP header value.
open class CustomHTTPHeaderValue {
}

/// Allow traffic towards application.
open class AllowAction {
    CustomRequestHandling: (CustomRequestHandling)?
}

/// The inspection behavior to fall back to if the JSON in the request body is invalid.
open class BodyParsingFallbackBehavior {
}

/// 
open class IPSetReferenceStatement {
    IPSetForwardedIPConfig: (IPSetForwardedIPConfiguration)?
    Arn: ResourceArn
}

/// Specifies the request's query string as an aggregate key for a rate-based rule.
open class RateLimitQueryString {
    TextTransformations: Listing<TextTransformation>
}

/// Specifies the IP address in the web request as an aggregate key for a rate-based rule.
open class RateLimitIP {
}

/// Custom request handling.
open class CustomRequestHandling {
    InsertHeaders: Listing<CustomHTTPHeader>
}

/// Valid values are TEXT_PLAIN, TEXT_HTML, and APPLICATION_JSON.
open class ResponseContentType {
}

/// The body of a web request. This immediately follows the request headers.
open class Body {
    OversizeHandling: (OversizeHandling)?
}

/// Handling of requests containing oversize fields
open class OversizeHandling {
}

/// Name of the RuleGroup.
open class EntityName {
}

/// Position of the evaluation in the FieldToMatch of request.
open class PositionalConstraint {
}

/// Specifies a single custom aggregate key for a rate-base rule.
open class RateBasedStatementCustomKey {
    Cookie: (RateLimitCookie)?
    Header: (RateLimitHeader)?
    IP: (RateLimitIP)?
    QueryString: (RateLimitQueryString)?
    ForwardedIP: (RateLimitForwardedIP)?
    HTTPMethod: (RateLimitHTTPMethod)?
    LabelNamespace: (RateLimitLabelNamespace)?
    QueryArgument: (RateLimitQueryArgument)?
    UriPath: (RateLimitUriPath)?
}

typealias JA3FingerprintFallbackBehavior = "MATCH"|"NO_MATCH"

/// Includes the JA3 fingerprint of a web request.
open class JA3Fingerprint {
    FallbackBehavior: JA3FingerprintFallbackBehavior|Mapping
}

/// Xss Match Statement.
open class XssMatchStatement {
    FieldToMatch: FieldToMatch
    TextTransformations: Listing<TextTransformation>
}

/// Includes cookies of a web request.
open class Cookies {
    MatchPattern: CookieMatchPattern
    MatchScope: MapMatchScope
    OversizeHandling: OversizeHandling
}

/// Count traffic towards application.
open class CountAction {
    CustomRequestHandling: (CustomRequestHandling)?
}

/// Custom response code.
open class ResponseStatusCode {
}

/// Sqli Match Statement.
open class SqliMatchStatement {
    SensitivityLevel: (SensitivityLevel)?
    FieldToMatch: FieldToMatch
    TextTransformations: Listing<TextTransformation>
}

typealias IPSetForwardedIPConfigurationPosition = "FIRST"|"LAST"|"ANY"

typealias IPSetForwardedIPConfigurationFallbackBehavior = "MATCH"|"NO_MATCH"

/// 
open class IPSetForwardedIPConfiguration {
    Position: IPSetForwardedIPConfigurationPosition|Mapping
    HeaderName: String(matches(Regex(#"^[a-zA-Z0-9-]+{1,255}$"#)))|Mapping
    FallbackBehavior: IPSetForwardedIPConfigurationFallbackBehavior|Mapping
}

/// Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
open class ChallengeAction {
    CustomRequestHandling: (CustomRequestHandling)?
}

/// Response content.
open class ResponseContent {
}

/// 
open class LabelSummary {
    Name: (LabelName)?
}

/// The parts of the request to match against using the MatchPattern.
open class MapMatchScope {
}

/// Id of the RuleGroup
open class EntityId {
}

/// Specifies a cookie as an aggregate key for a rate-based rule.
open class RateLimitCookie {
    Name: String(matches(Regex(#".*\S.*"#)))|Mapping
    TextTransformations: Listing<TextTransformation>
}

/// Specifies the request's HTTP method as an aggregate key for a rate-based rule.
open class RateLimitHTTPMethod {
}

/// 
open class RegexMatchStatement {
    RegexString: String|Mapping
    FieldToMatch: FieldToMatch
    TextTransformations: Listing<TextTransformation>
}

/// The pattern to look for in the request cookies.
open class CookieMatchPattern {
    All: (Dynamic)?
    IncludedCookies: (Listing<String|Mapping>)?
    ExcludedCookies: (Listing<String|Mapping>)?
}

/// Inspect the request body as JSON. The request body immediately follows the request headers.
open class JsonBody {
    MatchPattern: JsonMatchPattern
    MatchScope: JsonMatchScope
    InvalidFallbackBehavior: (BodyParsingFallbackBehavior)?
    OversizeHandling: (OversizeHandling)?
}

/// Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
open class RateLimitForwardedIP {
}

/// Text Transformation on the Search String before match.
open class TextTransformation {
    Priority: TextTransformationPriority
    Type: TextTransformationType
}

/// Priority of Rule being evaluated.
open class TextTransformationPriority {
}

/// 
open class GeoMatchStatement {
    CountryCodes: (Listing<String|Mapping>)?
    ForwardedIPConfig: (ForwardedIPConfiguration)?
}

/// HTTP header name.
open class CustomHTTPHeaderName {
}

/// Custom response body.
open class CustomResponseBody {
    Content: ResponseContent
    ContentType: ResponseContentType
}

/// 
open class LabelMatchScope {
}

/// 
open class LabelMatchStatement {
    Scope: LabelMatchScope
    Key: LabelMatchKey
}

/// 
open class ChallengeConfig {
    ImmunityTimeProperty: (ImmunityTimeProperty)?
}

/// The pattern to look for in the JSON body.
open class JsonMatchPattern {
    All: (Dynamic)?
    IncludedPaths: (Listing<JsonPointerPath>)?
}

typealias RateBasedStatementAggregateKeyType = "IP"|"FORWARDED_IP"|"CONSTANT"|"CUSTOM_KEYS"

/// 
open class RateBasedStatement {
    ForwardedIPConfig: (ForwardedIPConfiguration)?
    Limit: RateLimit
    EvaluationWindowSec: (EvaluationWindowSec)?
    AggregateKeyType: RateBasedStatementAggregateKeyType|Mapping
    CustomKeys: (Listing<RateBasedStatementCustomKey>)?
    ScopeDownStatement: (Statement)?
}

/// Use CLOUDFRONT for CloudFront RuleGroup, use REGIONAL for Application Load Balancer and API Gateway.
open class Scope {
}

/// 
open class RateLimit {
}

/// 
open class EvaluationWindowSec {
}

/// Block traffic towards application.
open class BlockAction {
    CustomResponse: (CustomResponse)?
}

typealias SizeConstraintStatementComparisonOperator = "EQ"|"NE"|"LE"|"LT"|"GE"|"GT"

/// Size Constraint statement.
open class SizeConstraintStatement {
    FieldToMatch: FieldToMatch
    ComparisonOperator: SizeConstraintStatementComparisonOperator|Mapping
    Size: Number|Mapping
    TextTransformations: Listing<TextTransformation>
}

/// Description of the entity.
open class EntityDescription {
}

/// The parts of the JSON to match against using the MatchPattern.
open class JsonMatchScope {
}

/// Specifies the request's URI Path as an aggregate key for a rate-based rule.
open class RateLimitUriPath {
    TextTransformations: Listing<TextTransformation>
}

/// Includes headers of a web request.
open class Headers {
    OversizeHandling: OversizeHandling
    MatchPattern: HeaderMatchPattern
    MatchScope: MapMatchScope
}

/// The pattern to look for in the request headers.
open class HeaderMatchPattern {
    All: (Dynamic)?
    IncludedHeaders: (Listing<String|Mapping>)?
    ExcludedHeaders: (Listing<String|Mapping>)?
}

/// Base64 encoded string that is searched to find a match.
open class SearchStringBase64 {
}

/// 
open class Label {
    Name: LabelName
}

/// 
open class ImmunityTimeProperty {
    ImmunityTime: Int|Mapping
}

/// 
open class NotStatement {
    Statement: Statement
}

/// Custom response.
open class CustomResponse {
    ResponseCode: ResponseStatusCode
    CustomResponseBodyKey: (String(matches(Regex(#"^[\w\-]+$"#)))|Mapping)?
    ResponseHeaders: (Listing<CustomHTTPHeader>)?
}

/// String that is searched to find a match.
open class SearchString {
}

/// 
open class CaptchaConfig {
    ImmunityTimeProperty: (ImmunityTimeProperty)?
}

/// First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
open class Statement {
    ByteMatchStatement: (ByteMatchStatement)?
    SqliMatchStatement: (SqliMatchStatement)?
    OrStatement: (OrStatement)?
    XssMatchStatement: (XssMatchStatement)?
    GeoMatchStatement: (GeoMatchStatement)?
    RegexMatchStatement: (RegexMatchStatement)?
    RegexPatternSetReferenceStatement: (RegexPatternSetReferenceStatement)?
    AndStatement: (AndStatement)?
    LabelMatchStatement: (LabelMatchStatement)?
    NotStatement: (NotStatement)?
    SizeConstraintStatement: (SizeConstraintStatement)?
    IPSetReferenceStatement: (IPSetReferenceStatement)?
    RateBasedStatement: (RateBasedStatement)?
}

/// Visibility Metric of the RuleGroup.
open class VisibilityConfig {
    SampledRequestsEnabled: Boolean|Mapping
    CloudWatchMetricsEnabled: Boolean|Mapping
    MetricName: String|Mapping
}

/// 
open class LabelMatchKey {
}

/// Contains the Rules that identify the requests that you want to allow, block, or count. In a RuleGroup, you also specify a default action (ALLOW or BLOCK), and the action for each Rule that you add to a RuleGroup, for example, block requests from specified IP addresses or block requests from specified referrers. You also associate the RuleGroup with a CloudFront distribution to identify the requests that you want AWS WAF to filter. If you add more than one Rule to a RuleGroup, a request needs to match only one of the specifications to be allowed, blocked, or counted.
open class RuleGroup extends cloudformation.Resource {

    Type = "AWS::WAFv2::RuleGroup"


    /// 
    hidden Description: (EntityDescription)?

    /// 
    hidden VisibilityConfig: VisibilityConfig

    /// Collection of Consumed Labels.
    hidden ConsumedLabels: (Listing<LabelSummary>)?

    /// 
    hidden Scope: Scope

    /// Collection of Available Labels.
    hidden AvailableLabels: (Listing<LabelSummary>)?

    /// 
    hidden Capacity: Int|Mapping

    /// 
    hidden Name: (EntityName)?

    /// Collection of Rules.
    hidden Rules: (Listing<Rule>)?

    /// 
    hidden Tags: (Listing<Tag>)?

    /// 
    hidden CustomResponseBodies: (CustomResponseBodies)?

    Properties {
        ["Description"] = if (Description == null) null else Description
        ["VisibilityConfig"] = if (VisibilityConfig == null) null else VisibilityConfig
        ["ConsumedLabels"] = if (ConsumedLabels == null) null else ConsumedLabels
        ["Scope"] = if (Scope == null) null else Scope
        ["AvailableLabels"] = if (AvailableLabels == null) null else AvailableLabels
        ["Capacity"] = if (Capacity == null) null else Capacity
        ["Name"] = if (Name == null) null else Name
        ["Rules"] = if (Rules == null) null else Rules
        ["Tags"] = if (Tags == null) null else Tags
        ["CustomResponseBodies"] = if (CustomResponseBodies == null) null else CustomResponseBodies
    }

}
